<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Java_100道面试题 | 刘文旭</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="人帅话不多，社会我旭哥，直接上车，以下为总结的100道面试题及答案详解，题比较多，建议先收藏。">
<meta name="keywords" content="面试,java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java_100道面试题">
<meta property="og:url" content="http://javar.xyz/2018/12/15/2018-12-15-Java_100道面试题/index.html">
<meta property="og:site_name" content="刘文旭">
<meta property="og:description" content="人帅话不多，社会我旭哥，直接上车，以下为总结的100道面试题及答案详解，题比较多，建议先收藏。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/FVVBZN3l1eSsMN20PSunguxeeeQpGOibO0DkACP3abwBOFzOuqHibJhIdteUI3HLoMJpGASEC5grjL0I9CqRfeqQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/FVVBZN3l1eSsMN20PSunguxeeeQpGOibO2gY7ia7QWwQR3N08xjz4MjP9ERddp6t12ZibENAE5iaicsOyleic1evkibaw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:updated_time" content="2018-12-15T12:01:04.416Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java_100道面试题">
<meta name="twitter:description" content="人帅话不多，社会我旭哥，直接上车，以下为总结的100道面试题及答案详解，题比较多，建议先收藏。">
<meta name="twitter:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/FVVBZN3l1eSsMN20PSunguxeeeQpGOibO0DkACP3abwBOFzOuqHibJhIdteUI3HLoMJpGASEC5grjL0I9CqRfeqQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
  
    <link rel="alternative" href="/atom.xml" title="刘文旭" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head></html>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://pjv20i5zh.bkt.clouddn.com/javar_xyz_head.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">刘文旭</a></h1>
		</hgroup>

		
		<p class="header-subtitle">你好，兄dei</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/RookieXv" title="github">github</a>
					        
								<a class="mail" target="_blank" href="/liuwx8102@163.com" title="mail">mail</a>
					        
								<a class="qq" target="_blank" href="/749455620" title="qq">qq</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/工具/" style="font-size: 10px;">工具</a> <a href="/tags/建站/" style="font-size: 10px;">建站</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/网站/" style="font-size: 10px;">网站</a> <a href="/tags/面试/" style="font-size: 20px;">面试</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/smackgg/hexo-theme-smackdown">smackdown</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">刘文旭</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://pjv20i5zh.bkt.clouddn.com/javar_xyz_head.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">刘文旭</h1>
			</hgroup>
			
			<p class="header-subtitle">你好，兄dei</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/RookieXv" title="github">github</a>
			        
						<a class="mail" target="_blank" href="/liuwx8102@163.com" title="mail">mail</a>
			        
						<a class="qq" target="_blank" href="/749455620" title="qq">qq</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-2018-12-15-Java_100道面试题" class="article article-type-post" itemscope="" itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/12/15/2018-12-15-Java_100道面试题/" class="article-date">
  	<time datetime="2018-12-15T11:52:05.000Z" itemprop="datePublished">2018-12-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java_100道面试题
      
          <span class="title-pop-out">[置顶]
      
    </span></h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/面试/">面试</a>
	</div>


        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>人帅话不多，社会我旭哥，直接上车，以下为总结的100道面试题及答案详解，题比较多，建议先收藏。</p>
</blockquote>
<a id="more"></a>
<p>目录</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>：Arraylist和Linkedlist的区别？</span><br><span class="line"><span class="number">2</span>：重载与重写有什么区别？</span><br><span class="line"><span class="number">3</span>：&amp;和&amp;&amp;有什么区别？</span><br><span class="line"><span class="number">4</span>：接口和抽象类有什么区别？</span><br><span class="line"><span class="number">5</span>：写出JDBC操作数据库的步骤？</span><br><span class="line"><span class="number">6</span>：HashTable和HashMap有什么区别？</span><br><span class="line"><span class="number">7</span>：创建多线程的方式有几种？分别是什么？线程死锁是如何产生的？如何防止线程死锁现象？</span><br><span class="line"><span class="number">8</span>：String， StringBuffer， StringBuilder 的区别？</span><br><span class="line"><span class="number">9</span>：TCP和UDP的区别？哪个是三次握手协议？</span><br><span class="line"><span class="number">10</span>：JSP的常用指令有哪些？</span><br><span class="line"><span class="number">11</span>：DI有几种方式、分别是什么，你常用的是哪种方式？</span><br><span class="line"><span class="number">12</span>：Mybatis中$和#在xml中取值有什么不同？</span><br><span class="line"><span class="number">13</span>：Session和Cookie有什么区别？</span><br><span class="line"><span class="number">14</span>：GET和POST请求的区别？</span><br><span class="line"><span class="number">15</span>：转发（forward）和重定向（redirect）的区别？</span><br><span class="line"><span class="number">16</span>：Hibernate与Mybatis区别？</span><br><span class="line"><span class="number">17</span>：列举struts2常见的组件有哪些？常见的配置标签有哪些？返回值类型有哪些？</span><br><span class="line"><span class="number">18</span>：用最有效率的方法算出<span class="number">2</span>乘以<span class="number">8</span>等于多少？</span><br><span class="line"><span class="number">19</span>：Spring常见的注解有哪些？</span><br><span class="line"><span class="number">20</span>：Debug模式下，快捷键有哪些，分别代表什么？</span><br><span class="line"><span class="number">21</span>：Tomcat如何修改端口号，如何清除项目缓存，默认并发量是多少？</span><br><span class="line"><span class="number">22</span>：final, finally, finalize的区别？</span><br><span class="line"><span class="number">23</span>：一个汉字几个字节，一个char类型的变量，可以储存一个汉字吗，为什么可以或者不可以？</span><br><span class="line"><span class="number">24</span>：谈谈Spring AOP的原理？</span><br><span class="line"><span class="number">25</span>：简要说明SSH框架搭建步骤？</span><br><span class="line"><span class="number">26</span>：简要说明SSM框架搭建步骤？</span><br><span class="line"><span class="number">27</span>：多线程中run和start方法有什么区别？</span><br><span class="line"><span class="number">28</span>：静态变量和实例变量有什么区别？</span><br><span class="line"><span class="number">29</span>：前后台数据交互的方式有哪些？</span><br><span class="line"><span class="number">30</span>：字节流和字符流有什么区别？</span><br><span class="line"><span class="number">31</span>：Redis支持哪些数据类型的存储？</span><br><span class="line"><span class="number">32</span>：Java如何调用Redis进行数据操作，并列举增删改查操作？</span><br><span class="line"><span class="number">33</span>：Nosql主要支持哪两种数据存储系统？</span><br><span class="line"><span class="number">34</span>：MongoDB的体系逻辑结构，主要有什么组成？</span><br><span class="line"><span class="number">35</span>：Redis和MongoDB分别应用于哪些应用场景？</span><br><span class="line"><span class="number">36</span>：Java如何链接MongoDB，写出逻辑代码？</span><br><span class="line"><span class="number">37</span>：如何给一张表增加一个字段，写出sql语句？</span><br><span class="line"><span class="number">38</span>：==与equals有什么区别？</span><br><span class="line"><span class="number">39</span>：++i与i++的区别？</span><br><span class="line"><span class="number">40</span>：List和Map有什么区别？</span><br><span class="line"><span class="number">41</span>：Integer与int的区别？</span><br><span class="line"><span class="number">42</span>：分别写出oracle、mysql的分页关键词？</span><br><span class="line"><span class="number">43</span>：谈谈你对MVC的理解？</span><br><span class="line"><span class="number">44</span>：如果equals方法比较为true，那么它们的Hashcode值一定相同吗？ 如</span><br><span class="line">果hashcode相同，那么equals方法比较一定为true吗？</span><br><span class="line"><span class="number">45</span>：简述servlet 生命周期？</span><br><span class="line"><span class="number">46</span>：进程和线程的区别是什么？</span><br><span class="line"><span class="number">47</span>：进程的几种状态分别是什么？</span><br><span class="line"><span class="number">48</span>：JDK和JRE的关系区别是什么？</span><br><span class="line"><span class="number">49</span>：SpringMVC运行原理是什么？</span><br><span class="line"><span class="number">50</span>：用户在浏览器中输入URL之后，发什么了什么？写出请求和响应的流程</span><br><span class="line"><span class="number">51</span>：响应结果状态码有哪些，并给出中文含义？</span><br><span class="line"><span class="number">52</span>：什么是ORM？</span><br><span class="line"><span class="number">53</span>：什么是IOC？</span><br><span class="line"><span class="number">54</span>：jsp的作用域有哪些？</span><br><span class="line"><span class="number">55</span>：sleep 和 wait 有什么区别？</span><br><span class="line"><span class="number">56</span>：Java 中的final关键字有哪些用法？</span><br><span class="line"><span class="number">57</span>：Error和Exception有什么区别？什么时候需要捕获异常，什么时候需要抛出异常？</span><br><span class="line"><span class="number">58</span>：写出冒泡排序的程序代码？</span><br><span class="line"><span class="number">59</span>：数据库集群模式下，如何保证主从数据库的数据一致性？以mysql数据库为例进行说明配置步骤？</span><br><span class="line"><span class="number">60</span>：简述JAVA中I/O和NIO的区别？</span><br><span class="line"><span class="number">61</span>：简述单例模式的特征和应用场景？</span><br><span class="line"><span class="number">62</span>：写出将<span class="number">1000</span>个存在重复手机号的号码池去重的JAVA代码？</span><br><span class="line"><span class="number">63</span>：Java接口的修饰符有哪些？</span><br><span class="line"><span class="number">64</span>：Java支持的数据类型有哪些？什么是自动拆装</span><br><span class="line"><span class="number">65</span>：Math.round(<span class="number">11.5</span>)等于多少? Math.round(<span class="number">-11.5</span>)等于多少?</span><br><span class="line"><span class="number">66</span>：写一单实例类要求精简、清晰？（单例模式）</span><br><span class="line"><span class="number">67</span>：构造器（constructor）是否可被重写（override）?是否可被重载？是否可被继承？</span><br><span class="line"><span class="number">68</span>：JSP和Servlet有哪些相同点和不同点，他们之间的联系是什么？</span><br><span class="line"><span class="number">69</span>：简述synchronized和java.util.concurrent.locks.Lock的异同 ？</span><br><span class="line"><span class="number">70</span>：解析xml和excel分别使用什么技术？</span><br><span class="line"><span class="number">71</span>：如何发布spring boot项目，简述步骤？</span><br><span class="line"><span class="number">72</span>：什么是java序列化，如何实现java序列化？</span><br><span class="line"><span class="number">73</span>：在JAVA中，如何跳出当前的多重嵌套循环？</span><br><span class="line"><span class="number">74</span>：面向对象的特征有哪些方面？</span><br><span class="line"><span class="number">75</span>：Collection 和 Collections的区别？</span><br><span class="line"><span class="number">76</span>：同步和异步有何异同，在什么情况下分别使用他们？举例说明。</span><br><span class="line"><span class="number">77</span>：abstract class和interface有什么区别?</span><br><span class="line"><span class="number">78</span>：GC是什么? 为什么要有GC?</span><br><span class="line"><span class="number">79</span>：请说出你所知道的线程同步的方法？</span><br><span class="line"><span class="number">80</span>：JSP的内置对象及方法？</span><br><span class="line"><span class="number">81</span>：如何现实servlet的单线程模式？</span><br><span class="line"><span class="number">82</span>：页面间对象传递的方法？</span><br><span class="line"><span class="number">83</span>：Request对象的主要方法？</span><br><span class="line"><span class="number">84</span>：J2ee常用的设计模式？说明工厂模式?</span><br><span class="line"><span class="number">85</span>：List、Map、Set三个接口，存取元素时，各有什么特点？</span><br><span class="line"><span class="number">86</span>：如何对数据库做优化？</span><br><span class="line"><span class="number">87</span>：如何对JVM进行性能调优？</span><br><span class="line"><span class="number">88</span>：如何实现集群模式下，session共享？</span><br><span class="line"><span class="number">89</span>：程序员如果想换行，应该怎么处理？</span><br><span class="line"><span class="number">90</span>：公司如果想换一个灯泡,请问需要几个java工程师？</span><br><span class="line"><span class="number">91</span>：Hibernate一级缓存和二级缓存的区别？</span><br><span class="line"><span class="number">92</span>：Hibernate有几种查询方式？</span><br><span class="line"><span class="number">93</span>：你对加班怎么看？能接受出差吗？</span><br><span class="line"><span class="number">94</span>：谈谈个人<span class="number">3</span><span class="number">-5</span>年的职业规划？</span><br><span class="line"><span class="number">95</span>：在项目开发中，曾经遇到什么困难、难解的问题？</span><br><span class="line"><span class="number">96</span>：为什么从上家公司离职？</span><br><span class="line"><span class="number">97</span>：你喜欢在什么样的团队进行工作？</span><br><span class="line"><span class="number">98</span>：做一个简单的自我介绍？</span><br><span class="line"><span class="number">99</span>：工作中，如果你和项目组长或者领导的意见不一样，应该怎么处理？</span><br><span class="line"><span class="number">100</span>：遇到需求变更如何处理？</span><br></pre></td></tr></table></figure>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/FVVBZN3l1eSsMN20PSunguxeeeQpGOibO0DkACP3abwBOFzOuqHibJhIdteUI3HLoMJpGASEC5grjL0I9CqRfeqQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>详情解答</p>
<h3 id="1：Arraylist和Linkedlist的区别？"><a href="#1：Arraylist和Linkedlist的区别？" class="headerlink" title="1：Arraylist和Linkedlist的区别？"></a>1：Arraylist和Linkedlist的区别？</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList、LinkedList、Vector和<span class="built_in">Stack</span>是<span class="built_in">List</span>的四个实现类，其中Vector是基于JDK1<span class="number">.0</span>，虽然实现了同步，但是效率低，已经不用了，<span class="built_in">Stack</span>继承Vector</span><br><span class="line">区别：</span><br><span class="line">   <span class="number">1.</span> ArrayList是实现了基于动态数组的数据结构，而LinkedList是基于链表的数据结构</span><br><span class="line">   <span class="number">2.</span> 对于随机访问get和<span class="built_in">set</span>，ArrayList要优于LinkedList，LinkedList不支持高效的随机访问</span><br><span class="line">   <span class="number">3.</span> ArrayList适合查找，LinkedList适合增删</span><br></pre></td></tr></table></figure>
<h3 id="2：重载与重写有什么区别？"><a href="#2：重载与重写有什么区别？" class="headerlink" title="2：重载与重写有什么区别？"></a>2：重载与重写有什么区别？</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">override（重写）</span><br><span class="line">　　 <span class="number">1.</span>方法名、参数、返回值相同。</span><br><span class="line">　　 <span class="number">2.</span>子类方法不能缩小父类方法的访问权限。</span><br><span class="line">　　 <span class="number">3.</span>子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。</span><br><span class="line">　　 <span class="number">4.</span>存在于父类和子类之间。</span><br><span class="line">　　 <span class="number">5.</span>方法被定义为final不能被重写。</span><br><span class="line">　overload（重载）</span><br><span class="line">　 　<span class="number">1.</span>参数类型、个数、顺序至少有一个不相同。 </span><br><span class="line">　 　<span class="number">2.</span>不能重载只有返回值不同的方法名。</span><br><span class="line">　　 <span class="number">3.</span>存在于父类和子类、同类中。</span><br></pre></td></tr></table></figure>
<h3 id="3：-amp-和-amp-amp-有什么区别？"><a href="#3：-amp-和-amp-amp-有什么区别？" class="headerlink" title="3：&amp;和&amp;&amp;有什么区别？"></a>3：&amp;和&amp;&amp;有什么区别？</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&amp;按位与:</span></span><br><span class="line">    <span class="number">1</span>.a<span class="meta">&amp;b是把a和b都转换成二进制数然后再进行与的运算</span></span><br><span class="line">    <span class="number">2</span>.不管前面的条件是否正确，后面都执行</span><br><span class="line"><span class="meta">&amp;&amp;逻辑与（短路功能）:</span></span><br><span class="line">    <span class="number">1</span>.a<span class="meta">&amp;&amp;b就是当且仅当两个操作数均为 true时，其结果才为 true；</span></span><br><span class="line">    <span class="number">2</span>.前面条件正确时，才执行后面，不正确时，就不执行，效率高</span><br></pre></td></tr></table></figure>
<h3 id="4：接口和抽象类有什么区别？"><a href="#4：接口和抽象类有什么区别？" class="headerlink" title="4：接口和抽象类有什么区别？"></a>4：接口和抽象类有什么区别？</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">抽象类（<span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span>）：</span></span><br><span class="line">    <span class="number">1</span>：<span class="keyword">abstract</span> 关键字修饰，并且没有方法体</span><br><span class="line">    <span class="number">2</span>：抽象类不能直接创建实例</span><br><span class="line">    <span class="number">3</span>：抽象类只能被继承，一个具体类继承一个抽象类，必须实现所有抽象方法</span><br><span class="line">接口（<span class="class"><span class="keyword">interface</span>）：</span></span><br><span class="line">    <span class="number">1</span>：实现接口的一定要实现接口里定义的所有方法</span><br><span class="line">    <span class="number">2</span>：接口可以实现多重继承</span><br><span class="line">区别：</span><br><span class="line">    <span class="number">1</span>：抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用</span><br><span class="line">    <span class="number">2</span>：一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类</span><br><span class="line">    <span class="number">3</span>：接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法</span><br><span class="line">    <span class="number">4</span>：抽象类中的成员可以是<span class="keyword">private</span>、默认、<span class="keyword">protected</span>、<span class="keyword">public</span>的，而接口中的成员全都是<span class="keyword">public</span>的</span><br><span class="line">    <span class="number">5</span>：抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法</span><br></pre></td></tr></table></figure>
<h3 id="5：写出JDBC操作数据库的步骤？"><a href="#5：写出JDBC操作数据库的步骤？" class="headerlink" title="5：写出JDBC操作数据库的步骤？"></a>5：写出JDBC操作数据库的步骤？</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1：加载驱动</span><br><span class="line">    Class.forName(<span class="string">"oracle.jdbc.driver.OracleDriver"</span>);</span><br><span class="line">2：创建连接</span><br><span class="line">   <span class="built_in"> Connection </span>con = DriverManager.getConnection(<span class="string">"jdbc:oracle:thin:@localhost:1521:orcl"</span>, <span class="string">"1111"</span>, <span class="string">"1111"</span>);</span><br><span class="line">3：创建语句</span><br><span class="line">    PreparedStatement ps = con.prepareStatement(<span class="string">"select * from user"</span>);</span><br><span class="line">4：执行语句</span><br><span class="line">    ResultSet rs = ps.executeQuery();</span><br><span class="line">5：处理结果</span><br><span class="line">    <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">        rs.get<span class="built_in">..</span><span class="built_in">..</span>.（“”）；</span><br><span class="line">    &#125;</span><br><span class="line">6：关闭资源</span><br><span class="line">    finally &#123;</span><br><span class="line">        <span class="keyword">if</span>(con != <span class="literal">null</span>) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                con.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="6：HashTable和HashMap有什么区别？"><a href="#6：HashTable和HashMap有什么区别？" class="headerlink" title="6：HashTable和HashMap有什么区别？"></a>6：HashTable和HashMap有什么区别？</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">HashMap</span>是Hashtable的轻量级实现（非线程安全的实现），他们都完成了Map接口</span><br><span class="line"><span class="number">2.</span>主要区别在于<span class="keyword">HashMap</span>允许空（<span class="keyword">null</span>）键值（<span class="built_in">key</span>）,由于非线程安全，效率上可能高Hashtable</span><br><span class="line"><span class="number">3.</span><span class="keyword">HashMap</span>允许将<span class="keyword">null</span>作为一个entry的<span class="built_in">key</span>或者value，而Hashtable不允许</span><br><span class="line"><span class="number">4.</span>最大的不同是，Hashtable的方法是Synchronize的，而<span class="keyword">HashMap</span>不是</span><br></pre></td></tr></table></figure>
<h3 id="7：创建多线程的方式有几种？分别是什么？线程死锁是如何产生的？如何防止线程死锁现象？"><a href="#7：创建多线程的方式有几种？分别是什么？线程死锁是如何产生的？如何防止线程死锁现象？" class="headerlink" title="7：创建多线程的方式有几种？分别是什么？线程死锁是如何产生的？如何防止线程死锁现象？"></a>7：创建多线程的方式有几种？分别是什么？线程死锁是如何产生的？如何防止线程死锁现象？</h3><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">方式：</span><br><span class="line">    继承Thread、实现 Runnable 接口</span><br><span class="line">产生:</span><br><span class="line">    -<span class="ruby"> 一个资源每次只能被一个进程使用</span></span><br><span class="line"><span class="ruby">    - 一个进程因请求发生阻塞时，依然对已获得的资源保持不放</span></span><br><span class="line"><span class="ruby">    - 进程已经获得资源使用权，但是一直未使用</span></span><br><span class="line"><span class="ruby">    - 同一个进程，频繁的获取资源的优先使用权，一直未释放</span></span><br><span class="line"><span class="ruby">防止：</span></span><br><span class="line"><span class="ruby">    加锁顺序（线程按照一定的顺序加锁）</span></span><br><span class="line"><span class="ruby">    加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）</span></span><br><span class="line"><span class="ruby">    死锁检测（一般是将所有的锁存放于map对象中，检测map中的锁）</span></span><br></pre></td></tr></table></figure>
<h3 id="8：String，-StringBuffer，-StringBuilder-的区别？"><a href="#8：String，-StringBuffer，-StringBuilder-的区别？" class="headerlink" title="8：String， StringBuffer， StringBuilder 的区别？"></a>8：String， StringBuffer， StringBuilder 的区别？</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>运行速度快慢为：StringBuilder &gt; <span class="built_in">StringBuffer</span> &gt; <span class="built_in">String</span></span><br><span class="line">    - （<span class="built_in">String</span>为字符串常量，而StringBuilder和<span class="built_in">StringBuffer</span>均为字符串变量，即<span class="built_in">String</span>对象一旦创建之后该对象是不可更改的）</span><br><span class="line"><span class="number">2.</span>StringBuilder是线程不安全的，而<span class="built_in">String</span>、<span class="built_in">StringBuffer</span>是线程安全的</span><br></pre></td></tr></table></figure>
<h3 id="9：TCP和UDP的区别？哪个是三次握手协议？"><a href="#9：TCP和UDP的区别？哪个是三次握手协议？" class="headerlink" title="9：TCP和UDP的区别？哪个是三次握手协议？"></a>9：TCP和UDP的区别？哪个是三次握手协议？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP稳定性较高，但效率低</span><br><span class="line">UDP通讯相反，效率较高，但稳定性较差</span><br></pre></td></tr></table></figure>
<h3 id="10：JSP的常用指令有哪些？"><a href="#10：JSP的常用指令有哪些？" class="headerlink" title="10：JSP的常用指令有哪些？"></a>10：JSP的常用指令有哪些？</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">三个编译指令为：<span class="selector-tag">page</span>、<span class="selector-tag">include</span>、<span class="selector-tag">taglib</span></span><br><span class="line">七个动作指令为：<span class="selector-tag">jsp</span><span class="selector-pseudo">:forward</span>、<span class="selector-tag">jsp</span><span class="selector-pseudo">:param</span>、<span class="selector-tag">jsp</span><span class="selector-pseudo">:include</span>、<span class="selector-tag">jsp</span><span class="selector-pseudo">:plugin</span>、<span class="selector-tag">jsp</span><span class="selector-pseudo">:useBean</span>、<span class="selector-tag">jsp</span><span class="selector-pseudo">:setProperty</span>、<span class="selector-tag">jsp</span><span class="selector-pseudo">:getProperty</span></span><br></pre></td></tr></table></figure>
<h3 id="11：DI有几种方式、分别是什么？"><a href="#11：DI有几种方式、分别是什么？" class="headerlink" title="11：DI有几种方式、分别是什么？"></a>11：DI有几种方式、分别是什么？</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>：Setter方法</span><br><span class="line"><span class="number">2</span>：构造器</span><br><span class="line"><span class="number">3</span>：接口注入</span><br><span class="line"></span><br><span class="line">注解实现注入(常用)</span><br></pre></td></tr></table></figure>
<h3 id="12：Mybatis中-和-在xml中取值有什么不同？"><a href="#12：Mybatis中-和-在xml中取值有什么不同？" class="headerlink" title="12：Mybatis中$和#在xml中取值有什么不同？"></a>12：Mybatis中$和#在xml中取值有什么不同？</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>mybatis 为我们提供了两种支持动态 sql 的语法：#&#123;&#125; 以及 $&#123;&#125;</span><br><span class="line"><span class="number">2.</span>#方式能够很大程度防止sql注入，$方式无法防止Sql注入</span><br><span class="line"><span class="number">3.</span>$方式一般用于传入数据库对象，例如传入表名</span><br><span class="line"><span class="number">4.</span>＃&#123;&#125;将传入的数据都当成一个字符串，会对自动传入的数据加一个双引号</span><br><span class="line"><span class="number">5.</span>一般能用#的就别用$</span><br></pre></td></tr></table></figure>
<h3 id="13：Session和Cookie有什么区别？"><a href="#13：Session和Cookie有什么区别？" class="headerlink" title="13：Session和Cookie有什么区别？"></a>13：Session和Cookie有什么区别？</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Cookie存在客户端、session数据放在服务器上</span><br><span class="line">cookie不是很安全，别人可以分析存放在本地的COOKIE并进行修改</span><br><span class="line">session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 </span><br><span class="line">单个cookie在客户端的限制是<span class="number">3</span>K，就是说一个站点在客户端存放的COOKIE不能大于<span class="number">3</span>K</span><br></pre></td></tr></table></figure>
<h3 id="14：GET和POST请求的区别？"><a href="#14：GET和POST请求的区别？" class="headerlink" title="14：GET和POST请求的区别？"></a>14：GET和POST请求的区别？</h3><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET：</span><br><span class="line">    <span class="number">1</span>：从服务器上获取数据，一般不能使用在写操作接口</span><br><span class="line">    <span class="number">2</span>：由<span class="keyword">URL</span>所限制，GET方式传输的数据大小有所限制，传送的数据量不超过<span class="number">2</span>KB</span><br><span class="line">    <span class="number">3</span>：请求的数据会附加在<span class="keyword">URL</span>之后，以？分隔<span class="keyword">URL</span>和传输数据，多个参数用&amp;连接</span><br><span class="line">    <span class="number">4</span>：安全性差</span><br><span class="line">POST:</span><br><span class="line">    <span class="number">1</span>：向服务器提交数据,一般处理写业务</span><br><span class="line">    <span class="number">2</span>：POST方式传送的数据量比较大，一般被默认为没有限制</span><br><span class="line">    <span class="number">3</span>：安全性高</span><br><span class="line">    <span class="number">4</span>：请的求的数据内容放置在HTML HEADER中</span><br></pre></td></tr></table></figure>
<h3 id="15：转发（forward）和重定向（redirect）的区别？"><a href="#15：转发（forward）和重定向（redirect）的区别？" class="headerlink" title="15：转发（forward）和重定向（redirect）的区别？"></a>15：转发（forward）和重定向（redirect）的区别？</h3><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>：效率上</span><br><span class="line">    转发（<span class="keyword">forward</span>） &gt; 重定向（redirect）</span><br><span class="line"><span class="number">2</span>：显示上</span><br><span class="line">    重定向（redirect）：显示新的URL</span><br><span class="line">    转发（<span class="keyword">forward</span>）：地址栏不变</span><br><span class="line"><span class="number">3</span>：数据上</span><br><span class="line">    转发（<span class="keyword">forward</span>）：可以共享request里面的数据</span><br><span class="line">    重定向（redirect）：不能</span><br><span class="line"><span class="number">4</span>：请求次数</span><br><span class="line">    重定向（redirect）是两次</span><br><span class="line">    转发（<span class="keyword">forward</span>）是一次</span><br></pre></td></tr></table></figure>
<h3 id="16：Hibernate与Mybatis区别？"><a href="#16：Hibernate与Mybatis区别？" class="headerlink" title="16：Hibernate与Mybatis区别？"></a>16：Hibernate与Mybatis区别？</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>：hibernate的扩展性和移植性比mybatis强</span><br><span class="line"><span class="number">2</span>：hibernate不需要写sql语句，会自动生成，而mybatis则需要写sql语句</span><br><span class="line"><span class="number">3</span>：hibernate支持事务、一级缓存、二级缓存、查询缓存等</span><br><span class="line"><span class="number">4</span>：hibernate自己提供分页功能，mybatis需要配置分页插件</span><br></pre></td></tr></table></figure>
<h3 id="17：列举struts2常见的组件有哪些？常见的配置标签有哪些？返回值类型有哪些？"><a href="#17：列举struts2常见的组件有哪些？常见的配置标签有哪些？返回值类型有哪些？" class="headerlink" title="17：列举struts2常见的组件有哪些？常见的配置标签有哪些？返回值类型有哪些？"></a>17：列举struts2常见的组件有哪些？常见的配置标签有哪些？返回值类型有哪些？</h3><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">组件：</span><br><span class="line">    strutsParperAndExecuteFilter</span><br><span class="line">    <span class="built_in">Action</span></span><br><span class="line">    Result</span><br><span class="line">    Interceptor</span><br><span class="line">标签：</span><br><span class="line">    package</span><br><span class="line">    <span class="built_in">action</span></span><br><span class="line">    result</span><br><span class="line">    <span class="built_in">param</span></span><br><span class="line">    interceptor</span><br><span class="line">返回值类型：</span><br><span class="line">    dispatcher</span><br><span class="line">    redirect</span><br><span class="line">    redirectAction</span><br><span class="line">    stream</span><br><span class="line">    json</span><br></pre></td></tr></table></figure>
<h3 id="18：用最有效率的方法算出2乘以8等于多少？"><a href="#18：用最有效率的方法算出2乘以8等于多少？" class="headerlink" title="18：用最有效率的方法算出2乘以8等于多少？"></a>18：用最有效率的方法算出2乘以8等于多少？</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">2 </span>&lt;&lt; <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h3 id="19：Spring常见的注解有哪些？"><a href="#19：Spring常见的注解有哪些？" class="headerlink" title="19：Spring常见的注解有哪些？"></a>19：Spring常见的注解有哪些？</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Autowired--</span>自动装配</span><br><span class="line"><span class="variable">@Component--</span>自动支持自动装配</span><br><span class="line"><span class="variable">@Repository--DAO</span>层实现</span><br><span class="line"><span class="variable">@Service--Service</span>层实现</span><br><span class="line"><span class="variable">@Controller--Web</span>层实现</span><br></pre></td></tr></table></figure>
<h3 id="20：Debug模式下，快捷键有哪些，分别代表什么？"><a href="#20：Debug模式下，快捷键有哪些，分别代表什么？" class="headerlink" title="20：Debug模式下，快捷键有哪些，分别代表什么？"></a>20：Debug模式下，快捷键有哪些，分别代表什么？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F5：进入方法内</span><br><span class="line">F6：执行下一步</span><br><span class="line">F7：跳出方法外</span><br><span class="line">F8：执行到下一个断点</span><br></pre></td></tr></table></figure>
<h3 id="21：Tomcat如何修改端口号，如何清除项目缓存，默认并发量是多少？"><a href="#21：Tomcat如何修改端口号，如何清除项目缓存，默认并发量是多少？" class="headerlink" title="21：Tomcat如何修改端口号，如何清除项目缓存，默认并发量是多少？"></a>21：Tomcat如何修改端口号，如何清除项目缓存，默认并发量是多少？</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">端口：server.xml</span><br><span class="line">项目缓存：删除work文件夹下的文件</span><br><span class="line">并发：<span class="number">150</span>-<span class="number">200</span></span><br></pre></td></tr></table></figure>
<h3 id="22：final-finally-finalize的区别？"><a href="#22：final-finally-finalize的区别？" class="headerlink" title="22：final, finally, finalize的区别？"></a>22：final, finally, finalize的区别？</h3><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span>—修饰符（关键字）</span><br><span class="line">    如果一个类被声明为<span class="keyword">final</span>，意味着它不能再派生出新的子类，不能作为父类被继承。</span><br><span class="line">    一个类不能既被声明为 <span class="keyword">abstract</span>的，又被声明为<span class="keyword">final</span>的</span><br><span class="line">    被声明为<span class="keyword">final</span>的方法也同样只能使用，不能重载</span><br><span class="line"><span class="keyword">finally</span>—异常处理时提供 <span class="keyword">finally</span> 块来执行操作</span><br><span class="line">    <span class="keyword">finally</span>块则是无论异常是否发生，都会执行<span class="keyword">finally</span>块的内容</span><br><span class="line"><span class="keyword">finalize</span>—方法名</span><br><span class="line">    <span class="keyword">finalize</span>() 方法是在垃圾收集器删除对象之前对这个对象调用的</span><br><span class="line">    它是在object类中定义的，所有的类都继承了它</span><br></pre></td></tr></table></figure>
<h3 id="23：一个汉字几个字节，一个char类型的变量，能储存一个汉字吗？"><a href="#23：一个汉字几个字节，一个char类型的变量，能储存一个汉字吗？" class="headerlink" title="23：一个汉字几个字节，一个char类型的变量，能储存一个汉字吗？"></a>23：一个汉字几个字节，一个char类型的变量，能储存一个汉字吗？</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两个字节，可以存储，前提是汉字必须是<span class="built_in">Unicode</span>编码</span><br></pre></td></tr></table></figure>
<h3 id="24：谈谈Spring-AOP的原理？"><a href="#24：谈谈Spring-AOP的原理？" class="headerlink" title="24：谈谈Spring AOP的原理？"></a>24：谈谈Spring AOP的原理？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AOP称为面向切面编程</span><br><span class="line">用于处理系统中分布于各个模块的横切关注点，比如事务管理、日志、缓存等等</span><br><span class="line">实现AOP功能关键是采用代理技术，主要分为静态代理<span class="comment">(AspectJ)</span>和动态代理</span><br><span class="line">JDK中采用Proxy类产生动态代理的方式为某个接口生成实现类，如果要为某个类生成子类，则可以用CGLIB</span><br></pre></td></tr></table></figure>
<h3 id="25：简要说明SSH框架搭建步骤？"><a href="#25：简要说明SSH框架搭建步骤？" class="headerlink" title="25：简要说明SSH框架搭建步骤？"></a>25：简要说明SSH框架搭建步骤？</h3><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1：Struts2</span><br><span class="line">    -<span class="ruby"> 导包</span></span><br><span class="line"><span class="ruby">    - 加载struts.xml</span></span><br><span class="line"><span class="ruby">    - 配置web.xml</span></span><br><span class="line"><span class="ruby">        - filter</span></span><br><span class="line"><span class="ruby"><span class="number">2</span>：Struts2+Spring</span></span><br><span class="line"><span class="ruby">    - 导中间包、Spring包</span></span><br><span class="line"><span class="ruby">    - 增加Spring的配置文件Applicationcontext.xml</span></span><br><span class="line"><span class="ruby">    - 配置web.xml</span></span><br><span class="line"><span class="ruby">        - context和监听</span></span><br><span class="line"><span class="ruby"><span class="number">3</span>：Hibernate</span></span><br><span class="line"><span class="ruby">    - 导包</span></span><br><span class="line"><span class="ruby">    - 增加hibernate的配置文件hibernate.hbm.cfg和表的映射文件</span></span><br><span class="line"><span class="ruby">        - 配置数据库的方言和连接、加载映射文件</span></span><br><span class="line"><span class="ruby"><span class="number">4</span>：Hibernate+Spring</span></span><br><span class="line"><span class="ruby">    - 导中间包</span></span><br><span class="line"><span class="ruby">    - 在spring的配置文件中加载hibernate的配置信息</span></span><br></pre></td></tr></table></figure>
<h3 id="26：简要说明SSM框架搭建步骤？"><a href="#26：简要说明SSM框架搭建步骤？" class="headerlink" title="26：简要说明SSM框架搭建步骤？"></a>26：简要说明SSM框架搭建步骤？</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>：Spring</span><br><span class="line">    - 导包</span><br><span class="line">    - 增加Spring的配置文件Applicationcontext.xml</span><br><span class="line">    - 配置web.xml</span><br><span class="line"><span class="number">2</span>：springMVC</span><br><span class="line">    - 导包</span><br><span class="line">    - 增加springMVC的配置文件context-dispatcher.xml</span><br><span class="line">    - 配置web.xml</span><br><span class="line"><span class="number">3</span>：mybatis</span><br><span class="line">    - 导包</span><br><span class="line">    - 增加mybatis的配置文件mybatis-config.xml</span><br><span class="line">    - 将mybatis的配置文件在spring和springMVC中进行引用和配置</span><br></pre></td></tr></table></figure>
<h3 id="27：多线程中run和start方法有什么区别？"><a href="#27：多线程中run和start方法有什么区别？" class="headerlink" title="27：多线程中run和start方法有什么区别？"></a>27：多线程中run和start方法有什么区别？</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread的<span class="literal">start</span>才是正在开启线程</span><br><span class="line">Run只是调用了一个普通方法，并没有启动另一个线程，程序还是会按照顺序执行相应的代码</span><br><span class="line"><span class="literal">Start</span>则表示，重新开启一个线程，不必等待其他线程运行完，只要得到cup就可以运行该线程</span><br></pre></td></tr></table></figure>
<h3 id="28：静态变量和实例变量有什么区别？"><a href="#28：静态变量和实例变量有什么区别？" class="headerlink" title="28：静态变量和实例变量有什么区别？"></a>28：静态变量和实例变量有什么区别？</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">静态变量前面要加<span class="keyword">static</span>，实例变量不用</span><br><span class="line">实例变量属于对象的属性，必须创建了实例对象，才可以被使用</span><br><span class="line">静态变量不属于某个实例对象，而是属于类，也叫类变量，不用创建任何实例对象就会被使用</span><br></pre></td></tr></table></figure>
<h3 id="29：前后台数据交互的方式有哪些？"><a href="#29：前后台数据交互的方式有哪些？" class="headerlink" title="29：前后台数据交互的方式有哪些？"></a>29：前后台数据交互的方式有哪些？</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json、<span class="built_in">file</span>、xml、jsonp等</span><br></pre></td></tr></table></figure>
<h3 id="30：字节流和字符流有什么区别？"><a href="#30：字节流和字符流有什么区别？" class="headerlink" title="30：字节流和字符流有什么区别？"></a>30：字节流和字符流有什么区别？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">字节流：按字节读写</span><br><span class="line">字符流：按字符</span><br><span class="line"></span><br><span class="line">通常在处理文本时优先使用字符流，其他的用字节流</span><br><span class="line">字节流在操作时本身不会用到缓冲区（内存），是文件本身直接操作的，而字符流在操作时使用了缓冲区，通过缓冲区再操作文件</span><br></pre></td></tr></table></figure>
<h3 id="31：Redis支持哪些数据类型的存储？"><a href="#31：Redis支持哪些数据类型的存储？" class="headerlink" title="31：Redis支持哪些数据类型的存储？"></a>31：Redis支持哪些数据类型的存储？</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>、<span class="built_in">list</span>、<span class="keyword">set</span>、zset、hash</span><br></pre></td></tr></table></figure>
<h3 id="32：Java如何调用Redis进行数据操作，并列举增删改查操作？"><a href="#32：Java如何调用Redis进行数据操作，并列举增删改查操作？" class="headerlink" title="32：Java如何调用Redis进行数据操作，并列举增删改查操作？"></a>32：Java如何调用Redis进行数据操作，并列举增删改查操作？</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 导包</span><br><span class="line"><span class="number">2.</span> Jedis jd = new Jedis(IP);</span><br><span class="line"><span class="number">3.</span> jd.ping();<span class="comment">//PONG</span></span><br></pre></td></tr></table></figure>
<h3 id="33：Nosql主要支持哪两种数据存储系统？"><a href="#33：Nosql主要支持哪两种数据存储系统？" class="headerlink" title="33：Nosql主要支持哪两种数据存储系统？"></a>33：Nosql主要支持哪两种数据存储系统？</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key-<span class="built_in">value</span><span class="comment">---Redis</span></span><br><span class="line">文档存储<span class="comment">-----MongoDB</span></span><br></pre></td></tr></table></figure>
<h3 id="34：MongoDB的体系逻辑结构，主要有什么组成？"><a href="#34：MongoDB的体系逻辑结构，主要有什么组成？" class="headerlink" title="34：MongoDB的体系逻辑结构，主要有什么组成？"></a>34：MongoDB的体系逻辑结构，主要有什么组成？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文档<span class="comment">(document)</span>、集合<span class="comment">(collection)</span>、数据库<span class="comment">(database)</span></span><br></pre></td></tr></table></figure>
<h3 id="35：Redis和MongoDB分别应用于哪些应用场景？"><a href="#35：Redis和MongoDB分别应用于哪些应用场景？" class="headerlink" title="35：Redis和MongoDB分别应用于哪些应用场景？"></a>35：Redis和MongoDB分别应用于哪些应用场景？</h3><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Redis：数据量较小的更性能操作和运算上</span><br><span class="line">MongoDB:主要解决海量数据的访问效率问题</span><br><span class="line">- 参考资料：</span><br><span class="line">https://mp.weixin.qq.com/s?__biz=MzIxMjg<span class="number">4</span>NDU<span class="number">1</span>NA==&amp;mid=<span class="number">2247484268</span>&amp;idx=<span class="number">1</span>&amp;sn=<span class="number">5431</span><span class="keyword">c</span><span class="number">00</span><span class="keyword">c</span><span class="number">451</span>ebeca<span class="number">8</span>aa<span class="number">99</span>ae<span class="number">59</span>f<span class="number">05</span>a<span class="number">3</span>a<span class="number">2</span>&amp;chksm=<span class="number">97</span>be<span class="number">0e49</span>a<span class="number">0</span><span class="keyword">c</span><span class="number">9875</span>fa<span class="number">918412</span>aa<span class="number">0</span>d<span class="number">2544</span><span class="keyword">c</span><span class="number">8</span>dbb<span class="number">02</span>b<span class="number">8875382</span>b<span class="number">08217</span>b<span class="number">1e7818</span>e<span class="number">7</span>ae<span class="number">913</span>d<span class="number">72</span>ae<span class="number">4107</span><span class="keyword">c</span>&amp;scene=<span class="number">21</span>#wechat_redirect</span><br></pre></td></tr></table></figure>
<h3 id="36：Java如何链接MongoDB，写出逻辑代码？"><a href="#36：Java如何链接MongoDB，写出逻辑代码？" class="headerlink" title="36：Java如何链接MongoDB，写出逻辑代码？"></a>36：Java如何链接MongoDB，写出逻辑代码？</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">导包</span><br><span class="line"><span class="comment">//建立连接</span></span><br><span class="line">MongoClient mc =  <span class="keyword">new</span> <span class="type">MongoClient</span>(<span class="string">"192.168.168.220"</span>, <span class="number">27017</span>);</span><br><span class="line">MongoDatabase db = mc.getDatabase(<span class="string">"db1"</span>);<span class="comment">//数据库名称</span></span><br></pre></td></tr></table></figure>
<h3 id="37：如何给一张表增加一个字段，写出sql语句？"><a href="#37：如何给一张表增加一个字段，写出sql语句？" class="headerlink" title="37：如何给一张表增加一个字段，写出sql语句？"></a>37：如何给一张表增加一个字段，写出sql语句？</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 <span class="builtin-name">add</span> 字段 类型 <span class="keyword">NOT</span> <span class="literal">NULL</span><span class="built_in"> Default </span>0;</span><br></pre></td></tr></table></figure>
<h3 id="38：-与equals有什么区别？"><a href="#38：-与equals有什么区别？" class="headerlink" title="38：==与equals有什么区别？"></a>38：==与equals有什么区别？</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">==：比较两个数据内存地址是否相同</span><br><span class="line"><span class="keyword">equals</span>：比较两个数据值是否一样</span><br></pre></td></tr></table></figure>
<h3 id="39：-i与i-的区别？"><a href="#39：-i与i-的区别？" class="headerlink" title="39：++i与i++的区别？"></a>39：++i与i++的区别？</h3><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">+</span><span class="literal">+</span><span class="comment">i:先赋值，后运算</span></span><br><span class="line"><span class="comment">i</span><span class="literal">+</span><span class="literal">+</span><span class="comment">：先运算，后赋值</span></span><br></pre></td></tr></table></figure>
<h3 id="40：List和Map有什么区别？"><a href="#40：List和Map有什么区别？" class="headerlink" title="40：List和Map有什么区别？"></a>40：List和Map有什么区别？</h3><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">list：</span><br><span class="line">    -<span class="ruby"> 链表</span></span><br><span class="line"><span class="ruby">    - 有序</span></span><br><span class="line"><span class="ruby">    - 继承Collection(set也是)</span></span><br><span class="line"><span class="ruby">    - 可以有重复的对象值，但是对象下标不能重复</span></span><br><span class="line"><span class="ruby">Map：</span></span><br><span class="line"><span class="ruby">    - key-value</span></span><br><span class="line"><span class="ruby">    - 无序</span></span><br><span class="line"><span class="ruby">    - 键不能有重复的 值可以用</span></span><br></pre></td></tr></table></figure>
<h3 id="41：Integer与int的区别？"><a href="#41：Integer与int的区别？" class="headerlink" title="41：Integer与int的区别？"></a>41：Integer与int的区别？</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> 是基本数据类型，初值为<span class="number">0</span></span><br><span class="line">Integer是<span class="keyword">int</span>的包装类，初值为<span class="keyword">null</span></span><br><span class="line">Integer缓存：注意拆箱和装箱（-<span class="number">128</span>-<span class="number">127</span>之间）</span><br><span class="line">原始类型：<span class="keyword">boolean</span>，<span class="keyword">char</span>，<span class="keyword">byte</span>，<span class="keyword">short</span>，<span class="keyword">int</span>，<span class="keyword">long</span>，<span class="keyword">float</span>，<span class="keyword">double</span></span><br><span class="line">包装类型：<span class="keyword">Boolean</span>，Character，<span class="keyword">Byte</span>，<span class="keyword">Short</span>，Integer，<span class="keyword">Long</span>，<span class="keyword">Float</span>，<span class="keyword">Double</span></span><br></pre></td></tr></table></figure>
<h3 id="42：分别写出oracle、mysql的分页关键词？"><a href="#42：分别写出oracle、mysql的分页关键词？" class="headerlink" title="42：分别写出oracle、mysql的分页关键词？"></a>42：分别写出oracle、mysql的分页关键词？</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oracle：rownum关键词、row_number()函数</span><br><span class="line">mysql：limit <span class="number">0</span>,<span class="number">5</span>    /    limit <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<h3 id="43：谈谈你对MVC的理解？"><a href="#43：谈谈你对MVC的理解？" class="headerlink" title="43：谈谈你对MVC的理解？"></a>43：谈谈你对MVC的理解？</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MVC：是一个框架设计模式，其中M（模型）、V（视图）、C（控制器）</span><br><span class="line">视图：视图向用户显示相关的数据，并接受用户的输入。视图不进行任何业务逻辑处理。如：<span class="keyword">jsp、html等</span></span><br><span class="line"><span class="keyword">模型：表示业务数据和业务处理。属于数据模型，如:entity、jdbc、hibernate、mybatis等</span></span><br><span class="line"><span class="keyword">控制器：接收、响应用户请求，servlet、action、controller等</span></span><br></pre></td></tr></table></figure>
<h3 id="44：如果equals方法比较为true，那么它们的Hashcode值一定相同吗？如果hashcode相同，那么equals方法比较一定为true吗？"><a href="#44：如果equals方法比较为true，那么它们的Hashcode值一定相同吗？如果hashcode相同，那么equals方法比较一定为true吗？" class="headerlink" title="44：如果equals方法比较为true，那么它们的Hashcode值一定相同吗？如果hashcode相同，那么equals方法比较一定为true吗？"></a>44：如果equals方法比较为true，那么它们的Hashcode值一定相同吗？如果hashcode相同，那么equals方法比较一定为true吗？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不一定相同</span><br><span class="line">一定</span><br></pre></td></tr></table></figure>
<h3 id="45：简述servlet-生命周期？"><a href="#45：简述servlet-生命周期？" class="headerlink" title="45：简述servlet 生命周期？"></a>45：简述servlet 生命周期？</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">通过调用 <span class="selector-tag">init</span> () 方法进行初始化</span><br><span class="line">调用 <span class="selector-tag">service</span>() 方法来处理客户端的请求</span><br><span class="line">通过调用 <span class="selector-tag">destroy</span>() 方法终止（结束）</span><br><span class="line"><span class="selector-tag">Servlet</span> 是由 <span class="selector-tag">JVM</span> 的垃圾回收器进行垃圾回收的</span><br></pre></td></tr></table></figure>
<h3 id="46：进程和线程的区别是什么？"><a href="#46：进程和线程的区别是什么？" class="headerlink" title="46：进程和线程的区别是什么？"></a>46：进程和线程的区别是什么？</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元</span><br><span class="line"><span class="bullet">- </span>同一个进程中可以包括多个线程</span><br><span class="line"><span class="bullet">- </span>进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束</span><br><span class="line"><span class="bullet">- </span>线程共享整个进程的资源（寄存器、堆栈、上下文），一个进行至少包括一个线程</span><br><span class="line"><span class="bullet">- </span>进程的创建调用fork或者vfork，而线程的创建调用pthread_create</span><br><span class="line"><span class="bullet">- </span>线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源</span><br></pre></td></tr></table></figure>
<h3 id="47：进程的几种状态分别是什么？"><a href="#47：进程的几种状态分别是什么？" class="headerlink" title="47：进程的几种状态分别是什么？"></a>47：进程的几种状态分别是什么？</h3><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">就绪状态：</span><br><span class="line"></span><br><span class="line">    当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态称为就绪状态</span><br><span class="line"></span><br><span class="line">运行状态：</span><br><span class="line"></span><br><span class="line">    当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为运行状态</span><br><span class="line"></span><br><span class="line">阻塞状态：</span><br><span class="line"></span><br><span class="line">    正在运行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起进程阻塞的事件可有多种，例如，等待<span class="keyword">I</span>/<span class="keyword">O</span>完成、申请缓冲区不能满足、等待信件(信号)等</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">状态转换：</span><br><span class="line"></span><br><span class="line">    就绪→运行：处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变成运行状态</span><br><span class="line"></span><br><span class="line">    运行→就绪：处于运行状态的进程在其运行过程中，因分配给它的一个时间片已用完而不得不让出处理机，于是进程从运行状态转变成就绪状态</span><br><span class="line"></span><br><span class="line">    运行→阻塞：正在运行的进程因等待某种事件发生而无法继续运行时，便从运行状态变成阻塞状态</span><br><span class="line"></span><br><span class="line">    阻塞→就绪：处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态转变为就绪状态</span><br></pre></td></tr></table></figure>
<h3 id="48：JDK和JRE的关系区别是什么？"><a href="#48：JDK和JRE的关系区别是什么？" class="headerlink" title="48：JDK和JRE的关系区别是什么？"></a>48：JDK和JRE的关系区别是什么？</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">JDK是Java的开发工具，JDK包含JRE</span></span><br><span class="line"><span class="keyword">JRE只是Java程序的运行环境，它最核心的内容就是JVM（Java虚拟机）及核心类库</span></span><br></pre></td></tr></table></figure>
<h3 id="49：SpringMVC运行原理是什么？"><a href="#49：SpringMVC运行原理是什么？" class="headerlink" title="49：SpringMVC运行原理是什么？"></a>49：SpringMVC运行原理是什么？</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>客户端请求提交到DispatcherServlet </span><br><span class="line"><span class="number">2.</span>由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller </span><br><span class="line"><span class="number">3.</span>DispatcherServlet将请求提交到Controller </span><br><span class="line"><span class="number">4.</span>Controller调用业务逻辑处理后，返回ModelAndView </span><br><span class="line"><span class="number">5.</span>DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图 </span><br><span class="line"><span class="number">6.</span>视图负责将结果显示到客户端 </span><br><span class="line">DispatcherServlet是整个Spring MVC的核心。它负责接收HTTP请求组织协调Spring MVC的各个组成部分</span><br></pre></td></tr></table></figure>
<h3 id="50：用户在浏览器中输入URL之后，发什么了什么？写出请求和响应的流程"><a href="#50：用户在浏览器中输入URL之后，发什么了什么？写出请求和响应的流程" class="headerlink" title="50：用户在浏览器中输入URL之后，发什么了什么？写出请求和响应的流程"></a>50：用户在浏览器中输入URL之后，发什么了什么？写出请求和响应的流程</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>：域名解析</span><br><span class="line"><span class="number">2</span>：TCP三次握手</span><br><span class="line"><span class="number">3</span>：浏览器向服务器发送http请求</span><br><span class="line"><span class="number">4</span>：浏览器发送请求头信息</span><br><span class="line"><span class="number">5</span>：服务器处理请求</span><br><span class="line"><span class="number">6</span>：服务器做出应答</span><br><span class="line"><span class="number">7</span>：服务器发送应答头信息</span><br><span class="line"><span class="number">8</span>：服务器发送数据</span><br><span class="line"><span class="number">9</span>：TCP连接关闭</span><br></pre></td></tr></table></figure>
<h3 id="51：响应结果状态码有哪些，并给出中文含义？"><a href="#51：响应结果状态码有哪些，并给出中文含义？" class="headerlink" title="51：响应结果状态码有哪些，并给出中文含义？"></a>51：响应结果状态码有哪些，并给出中文含义？</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>**：信息性状态码</span><br><span class="line"><span class="number">2</span>**：成功状态码</span><br><span class="line">    <span class="number">200</span>：请求正常成功</span><br><span class="line">    <span class="number">204</span>：指示请求成功但没有返回新信息</span><br><span class="line">    <span class="number">206</span>：指示服务器已完成对资源的部分 GET 请求</span><br><span class="line"><span class="number">3</span>**：重定向状态码</span><br><span class="line">    <span class="number">301</span>：永久性重定向</span><br><span class="line">    <span class="number">302</span>：临时性重定向</span><br><span class="line">    <span class="number">304</span>：服务器端允许请求访问资源，但未满足条件</span><br><span class="line"><span class="number">4</span>**：客户端错误状态码</span><br><span class="line">    <span class="number">400</span>：请求报文中存在语法错误</span><br><span class="line">    <span class="number">401</span>：发送的请求需要有通过HTTP认证的认证信息</span><br><span class="line">    <span class="number">403</span>：对请求资源的访问被服务器拒绝了</span><br><span class="line">    <span class="number">404</span>：服务器上无法找到请求的资源</span><br><span class="line"><span class="number">5</span>**：服务器错误状态码</span><br><span class="line">    <span class="number">500</span>：服务器端在执行请求时发生了错误</span><br><span class="line">    <span class="number">503</span>：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</span><br></pre></td></tr></table></figure>
<h3 id="52：什么是ORM？"><a href="#52：什么是ORM？" class="headerlink" title="52：什么是ORM？"></a>52：什么是ORM？</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对象关系映射（<span class="selector-tag">Object</span> <span class="selector-tag">Relational</span> <span class="selector-tag">Mapping</span>，简称<span class="selector-tag">ORM</span>）</span><br><span class="line">为了解决面向对象与关系数据库存在的互不匹配的现象的技术</span><br><span class="line"><span class="selector-tag">ORM</span>是通过使用描述对象和数据库之间映射的元数据(元数据一般采用XML格式)，将程序中的对象自动持久化到关系数据库中</span><br><span class="line"><span class="selector-tag">Java</span>典型的<span class="selector-tag">ORM</span>中间件有<span class="selector-pseudo">:Hibernate</span>,<span class="selector-tag">ibatis</span>,<span class="selector-tag">speedframework</span>,<span class="selector-tag">mybatis</span></span><br></pre></td></tr></table></figure>
<h3 id="53：什么是IOC？"><a href="#53：什么是IOC？" class="headerlink" title="53：什么是IOC？"></a>53：什么是IOC？</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(Inversion <span class="keyword">of</span> Control,简称IOC)，即控制反转，是一种设计模式，是spring的核心</span><br><span class="line">可以解决代码耦合，由IOC容器来管理对象的生命周期、依赖关系等。</span><br><span class="line">举个栗子：</span><br><span class="line">    我们是如何找女朋友的？</span><br><span class="line">    常见的情况是，我们到处去看哪里有长得漂亮的mm，然后打听她们的兴趣爱好、微信号、手机号、ip号、………，想办法认识她们，投其所好送其所要，然后....,这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁，耦合度比较高。</span><br><span class="line">    IOC：相当于第三方“婚姻介绍所”，手里有许多mm的资料，只需要你告诉介绍所，你需要什么样的女朋友，然后介绍所会自动匹配适合你的mm，然后给你，你只需要去和她谈恋爱、结婚就行了。简单明了，如果不符合你的要求，你可以抛出异常啊......虽有的对象都有你自己决定，spring也是如此，所有的对象都被spring控制。</span><br><span class="line">当前比较知名的IOC容器有：Spring、JBoss、EJB等。</span><br></pre></td></tr></table></figure>
<h3 id="54：jsp的作用域有哪些？"><a href="#54：jsp的作用域有哪些？" class="headerlink" title="54：jsp的作用域有哪些？"></a>54：jsp的作用域有哪些？</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">page：当前页面有效</span><br><span class="line">request：一次会话请求有效</span><br><span class="line">session：浏览器进程，只要浏览器不关闭，则一直有效</span><br><span class="line"><span class="built_in">application</span>：服务器只要运行，则有效</span><br></pre></td></tr></table></figure>
<h3 id="55：sleep-和-wait-有什么区别？"><a href="#55：sleep-和-wait-有什么区别？" class="headerlink" title="55：sleep 和 wait 有什么区别？"></a>55：sleep 和 wait 有什么区别？</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sleep</span>：</span><br><span class="line">    <span class="number">1</span>：属于Thread类，表示让一个线程进入睡眠状态，等待一定的时间之后，自动醒来进入到可运行状态，不会马上进入运行状态</span><br><span class="line">    <span class="number">2</span>：<span class="built_in">sleep</span>方法没有释放锁</span><br><span class="line">    <span class="number">3</span>：<span class="built_in">sleep</span>必须捕获异常</span><br><span class="line"><span class="built_in">wait</span>：</span><br><span class="line">    <span class="number">1</span>：属于Object，一旦一个对象调用了<span class="built_in">wait</span>方法，必须要采用notify()和notifyAll()方法唤醒该进程</span><br><span class="line">    <span class="number">2</span>：<span class="built_in">wait</span>方法释放了锁</span><br><span class="line">    <span class="number">3</span>：<span class="built_in">wait</span>不需要捕获异常</span><br></pre></td></tr></table></figure>
<h3 id="56：Java-中的final关键字有哪些用法？"><a href="#56：Java-中的final关键字有哪些用法？" class="headerlink" title="56：Java 中的final关键字有哪些用法？"></a>56：Java 中的final关键字有哪些用法？</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>：修饰类：表示该类不能被继承</span><br><span class="line"><span class="number">2</span>：修饰方法：表示方法不能被重写</span><br><span class="line"><span class="number">3</span>：修饰变量：表示变量只能一次赋值以后值不能被修改（常量）</span><br></pre></td></tr></table></figure>
<h3 id="57：Error和Exception有什么区别？什么时候需要捕获异常，什么时候需要抛出异常？"><a href="#57：Error和Exception有什么区别？什么时候需要捕获异常，什么时候需要抛出异常？" class="headerlink" title="57：Error和Exception有什么区别？什么时候需要捕获异常，什么时候需要抛出异常？"></a>57：Error和Exception有什么区别？什么时候需要捕获异常，什么时候需要抛出异常？</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>:Error表示系统级的错误和程序不必处理的异常,有可能恢复，但是恢复比较困难的严重问题。</span><br><span class="line"><span class="number">2</span>：Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况</span><br><span class="line">异常处理的原则：</span><br><span class="line">    <span class="number">1</span>：System<span class="selector-class">.out</span><span class="selector-class">.println</span>是高代价的。调用System<span class="selector-class">.out</span><span class="selector-class">.println</span>会降低系统吞吐量</span><br><span class="line">    <span class="number">2</span>：在生产环境中别用异常的printStackTrace()方法。</span><br><span class="line">    <span class="number">3</span>：如果你不能处理异常，不要捕获该异常</span><br><span class="line">    <span class="number">4</span>：如果要捕获，应在离异常源近的地方捕获它</span><br><span class="line">    <span class="number">5</span>：捕获的异常一定要做处理</span><br><span class="line">    <span class="number">6</span>：可以自定义异常</span><br><span class="line">    <span class="number">7</span>：就近原则</span><br></pre></td></tr></table></figure>
<h3 id="58：写出冒泡排序的程序代码？"><a href="#58：写出冒泡排序的程序代码？" class="headerlink" title="58：写出冒泡排序的程序代码？"></a>58：写出冒泡排序的程序代码？</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">高逼格的代码：</span><br><span class="line">接口：</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 排序器接口(策略模式: 将算法封装到具有共同接口的独立的类中使得它们可以相互替换)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> interface Sorter &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 排序</span></span><br><span class="line"><span class="comment">    * @param list 待排序的数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] <span class="built_in">list</span>)</span></span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 排序</span></span><br><span class="line"><span class="comment">    * @param list 待排序的数组</span></span><br><span class="line"><span class="comment">    * @param comp 比较两个对象的比较器</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] <span class="built_in">list</span>, Comparator&lt;T&gt; comp)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">实现类：</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSorter</span> <span class="title">implements</span> <span class="title">Sorter</span> &#123;</span></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] <span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">        boolean swapped = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, len = <span class="built_in">list</span>.length; i &lt; len &amp;&amp; swapped; ++i) &#123;</span><br><span class="line">            swapped = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">list</span>[j].compareTo(<span class="built_in">list</span>[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    T temp = <span class="built_in">list</span>[j];</span><br><span class="line">                    <span class="built_in">list</span>[j] = <span class="built_in">list</span>[j + <span class="number">1</span>];</span><br><span class="line">                    <span class="built_in">list</span>[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    swapped = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(T[] <span class="built_in">list</span>, Comparator&lt;T&gt; comp)</span> </span>&#123;</span><br><span class="line">        boolean swapped = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, len = <span class="built_in">list</span>.length; i &lt; len &amp;&amp; swapped; ++i) &#123;</span><br><span class="line">            swapped = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (comp.compare(<span class="built_in">list</span>[j], <span class="built_in">list</span>[j + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    T temp = <span class="built_in">list</span>[j];</span><br><span class="line">                    <span class="built_in">list</span>[j] = <span class="built_in">list</span>[j + <span class="number">1</span>];</span><br><span class="line">                    <span class="built_in">list</span>[j + <span class="number">1</span>] = temp;</span><br><span class="line">                    swapped = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="59：数据库集群模式下，如何保证主从数据库的数据一致性？以mysql数据库为例进行说明配置步骤？"><a href="#59：数据库集群模式下，如何保证主从数据库的数据一致性？以mysql数据库为例进行说明配置步骤？" class="headerlink" title="59：数据库集群模式下，如何保证主从数据库的数据一致性？以mysql数据库为例进行说明配置步骤？"></a>59：数据库集群模式下，如何保证主从数据库的数据一致性？以mysql数据库为例进行说明配置步骤？</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>：开启所有服务器的二进制文件</span><br><span class="line"><span class="number">2</span>：开启所有从服务的IO和SQL线程</span><br><span class="line"><span class="number">3</span>：配置主从连接的用户信息和主从信息</span><br><span class="line"><span class="number">4</span>：开启<span class="number">3306</span>端口号</span><br></pre></td></tr></table></figure>
<h3 id="60：简述JAVA中I-O和NIO的区别？"><a href="#60：简述JAVA中I-O和NIO的区别？" class="headerlink" title="60：简述JAVA中I/O和NIO的区别？"></a>60：简述JAVA中I/O和NIO的区别？</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NIO:是一种<span class="keyword">new</span> IO，其目的是为了实现高速IO的代码，将IO操作并转换为操作系统，属于非阻塞型，java.nio.*，是以块（缓冲区）的形式就行数据的传输</span><br><span class="line">IO：是以流的方式就行数据的传输，属于阻塞型，影响程序的性能</span><br><span class="line">传统阻塞IO，如果你要<span class="built_in">read</span>/<span class="built_in">write</span>( <span class="keyword">byte</span>[<span class="number">10</span>M])一个<span class="number">10</span>M的文件，一旦调用了<span class="built_in">read</span>/<span class="built_in">write</span>( <span class="keyword">byte</span>[<span class="number">10</span>M])这个方法，就得等<span class="number">10</span>M全部<span class="built_in">read</span>/<span class="built_in">write</span>，方法底层才会返回。</span><br><span class="line">非阻塞线程，调用<span class="built_in">read</span>/<span class="built_in">write</span>( <span class="keyword">byte</span>[<span class="number">10</span>M])方法立即返回，当然这并不能代表<span class="number">10</span>M已经<span class="built_in">read</span>/<span class="built_in">write</span>完成，你需要检测这个<span class="keyword">byte</span>[<span class="number">10</span>M]的缓冲区</span><br><span class="line">java BIO：同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善；</span><br><span class="line">java NIO：同步非阻塞，服务器实现模式为一个请求一个线程，NIO多线程对某资源进行IO操作时会先把资源先操作至内存缓冲区。然后询问是否IO操作就绪，是则进行IO操作，否则进行下一步操作，然后不断的轮询是否IO操作就绪，直到iIO操作就绪后进行相关操作</span><br><span class="line">java AIO：异步非阻塞，异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</span><br><span class="line">BIO和NIO的异同：</span><br><span class="line">    共同点：两者都是同步操作。即必须先进行IO操作后才能进行下一步操作。</span><br><span class="line">    不同点：BIO多线程对某资源进行IO操作时会出现阻塞，即一个线程进行IO操作完才会通知另外的IO操作线程，必须等待。</span><br></pre></td></tr></table></figure>
<h3 id="61：简述单例模式的特征和应用场景？"><a href="#61：简述单例模式的特征和应用场景？" class="headerlink" title="61：简述单例模式的特征和应用场景？"></a>61：简述单例模式的特征和应用场景？</h3><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">单例模式（Singleton），也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。</span><br><span class="line">单例模式只允许创建一个对象，因此节省内存，加快对象访问速度</span><br><span class="line">单例模式要素： </span><br><span class="line">    a.私有构造方法 </span><br><span class="line">    b.私有静态引用指向自己实例 </span><br><span class="line">    c.以自己实例为返回值的公有静态方法 </span><br><span class="line">饿汉式：单例实例在类装载时就构建，急切初始化。（预先加载法） </span><br><span class="line">    优点 </span><br><span class="line">        1.线程安全 </span><br><span class="line">        2.在类加载的同时已经创建好一个静态对象，调用时反应速度快 </span><br><span class="line">    缺点 </span><br><span class="line">         资源效率不高，可能getInstance()永远不会执行到，但执行该类的其他静态方法或者加载了该类（class.forName)，那么这个实例仍然初始化 </span><br><span class="line">懒汉式：单例实例在第一次被使用时构建，延迟初始化。 </span><br><span class="line">应用场景：</span><br><span class="line">    -<span class="ruby"> 需要频繁实例化然后销毁的对象</span></span><br><span class="line"><span class="ruby">    - 创建对象时耗时过多或者耗资源过多，但又经常用到的对象</span></span><br><span class="line"><span class="ruby">    - 有状态的工具类对象</span></span><br><span class="line"><span class="ruby">    - 频繁访问数据库或文件的对象</span></span><br><span class="line"><span class="ruby">    - 网站计数器，一般是采用单例模式实现</span></span><br><span class="line"><span class="ruby">    - 由于配置文件一般都是共享资源，即web应用的配置对象的读取，一般采用单例模式来实现。如：spring的配置文件的读取等</span></span><br><span class="line"><span class="ruby">    - 多线程的线程池的设计一般也是采用单例模式</span></span><br><span class="line"><span class="ruby">    - 数据库连接池的设计</span></span><br></pre></td></tr></table></figure>
<h3 id="62：写出将1000个存在重复手机号的号码池去重的JAVA代码？"><a href="#62：写出将1000个存在重复手机号的号码池去重的JAVA代码？" class="headerlink" title="62：写出将1000个存在重复手机号的号码池去重的JAVA代码？"></a>62：写出将1000个存在重复手机号的号码池去重的JAVA代码？</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class DemoPhone1 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        phoneDis();</span><br><span class="line">        phoneDis2();</span><br><span class="line">        phoneDis3();</span><br><span class="line">        phoneDis4();</span><br><span class="line">        phoneDis5();</span><br><span class="line">        phoneDis6();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> phoneDis()&#123;</span><br><span class="line">        <span class="keyword">String</span>[] <span class="keyword">array</span> = &#123;<span class="string">"18310141089"</span>,<span class="string">"18310141089"</span>,<span class="string">"18310141080"</span>,<span class="string">"18310141083"</span>,<span class="string">"18310141089"</span>,<span class="string">"18310141489"</span>&#125;;  </span><br><span class="line">        List&lt;<span class="keyword">String</span>&gt; result = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();  </span><br><span class="line">        <span class="keyword">boolean</span> flag;  </span><br><span class="line">        <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">array</span>.length;i++)&#123;  </span><br><span class="line">            flag = false;  </span><br><span class="line">            <span class="built_in">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;result.<span class="built_in">size</span>();j++)&#123;  </span><br><span class="line">                <span class="built_in">if</span>(<span class="keyword">array</span>[i].equals(result.<span class="built_in">get</span>(j)))&#123;  </span><br><span class="line">                    flag = true;  </span><br><span class="line">                    <span class="built_in">break</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="built_in">if</span>(!flag)&#123;  </span><br><span class="line">                result.add(<span class="keyword">array</span>[i]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">String</span>[] arrayResult = (<span class="keyword">String</span>[]) result.toArray(<span class="keyword">new</span> <span class="keyword">String</span>[result.<span class="built_in">size</span>()]);  </span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"方法1："</span> + Arrays.toString(arrayResult));  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> phoneDis2()&#123;</span><br><span class="line">        <span class="keyword">String</span>[] <span class="keyword">array</span> = &#123;<span class="string">"18310141089"</span>,<span class="string">"18310141089"</span>,<span class="string">"18310141080"</span>,<span class="string">"18310141083"</span>,<span class="string">"18310141089"</span>,<span class="string">"18310141489"</span>&#125;;  </span><br><span class="line">        List&lt;<span class="keyword">String</span>&gt; list = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();  </span><br><span class="line">        list.add(<span class="keyword">array</span>[<span class="number">0</span>]);  </span><br><span class="line">        <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="keyword">array</span>.length;i++)&#123;  </span><br><span class="line">            <span class="built_in">if</span>(list.toString().indexOf(<span class="keyword">array</span>[i]) == <span class="number">-1</span>)&#123;  </span><br><span class="line">               list.add(<span class="keyword">array</span>[i]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">String</span>[] arrayResult = (<span class="keyword">String</span>[]) list.toArray(<span class="keyword">new</span> <span class="keyword">String</span>[list.<span class="built_in">size</span>()]);  </span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"方法2："</span> + Arrays.toString(arrayResult));  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> phoneDis3()&#123;</span><br><span class="line">        <span class="keyword">String</span>[] <span class="keyword">array</span> = &#123;<span class="string">"18310141089"</span>,<span class="string">"18310141089"</span>,<span class="string">"18310141080"</span>,<span class="string">"18310141083"</span>,<span class="string">"18310141089"</span>,<span class="string">"18310141489"</span>&#125;;  </span><br><span class="line">        List&lt;<span class="keyword">String</span>&gt; list = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();  </span><br><span class="line">        <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">array</span>.length;i++)&#123;  </span><br><span class="line">            <span class="built_in">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;<span class="keyword">array</span>.length;j++)&#123;  </span><br><span class="line">                <span class="built_in">if</span>(<span class="keyword">array</span>[i] == <span class="keyword">array</span>[j])&#123;  </span><br><span class="line">                    j = ++i;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            list.add(<span class="keyword">array</span>[i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">String</span>[] arrayResult = (<span class="keyword">String</span>[]) list.toArray(<span class="keyword">new</span> <span class="keyword">String</span>[list.<span class="built_in">size</span>()]);  </span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"方法3："</span> + Arrays.toString(arrayResult));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> phoneDis4()&#123;</span><br><span class="line">        <span class="keyword">String</span>[] <span class="keyword">array</span> = &#123;<span class="string">"18310141089"</span>,<span class="string">"18310141089"</span>,<span class="string">"18310141080"</span>,<span class="string">"18310141083"</span>,<span class="string">"18310141089"</span>,<span class="string">"18310141489"</span>&#125;;  </span><br><span class="line">        Arrays.sort(<span class="keyword">array</span>);  </span><br><span class="line">        List&lt;<span class="keyword">String</span>&gt; list = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();  </span><br><span class="line">        list.add(<span class="keyword">array</span>[<span class="number">0</span>]);  </span><br><span class="line">        <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="keyword">array</span>.length;i++)&#123;  </span><br><span class="line">          <span class="built_in">if</span>(!<span class="keyword">array</span>[i].equals(list.<span class="built_in">get</span>(list.<span class="built_in">size</span>()<span class="number">-1</span>)))&#123;  </span><br><span class="line">             list.add(<span class="keyword">array</span>[i]);  </span><br><span class="line">          &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">       <span class="keyword">String</span>[] arrayResult = (<span class="keyword">String</span>[]) list.toArray(<span class="keyword">new</span> <span class="keyword">String</span>[list.<span class="built_in">size</span>()]);  </span><br><span class="line">       System.out.<span class="built_in">println</span>(<span class="string">"方法4："</span> + Arrays.toString(arrayResult));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> phoneDis5()&#123;</span><br><span class="line">        <span class="keyword">String</span>[] <span class="keyword">array</span> = &#123;<span class="string">"18310141089"</span>,<span class="string">"18310141089"</span>,<span class="string">"18310141080"</span>,<span class="string">"18310141083"</span>,<span class="string">"18310141089"</span>,<span class="string">"18310141489"</span>&#125;;  </span><br><span class="line">        Set&lt;<span class="keyword">String</span>&gt; set = <span class="keyword">new</span> HashSet&lt;<span class="keyword">String</span>&gt;();  </span><br><span class="line">        <span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="keyword">array</span>.length;i++)&#123;  </span><br><span class="line">            set.add(<span class="keyword">array</span>[i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">String</span>[] arrayResult = (<span class="keyword">String</span>[]) set.toArray(<span class="keyword">new</span> <span class="keyword">String</span>[set.<span class="built_in">size</span>()]);  </span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"方法5："</span> + Arrays.toString(arrayResult)); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> phoneDis6() &#123;</span><br><span class="line">        <span class="keyword">String</span>[] <span class="keyword">array</span> = &#123; <span class="string">"18310141089"</span>, <span class="string">"18310141089"</span>, <span class="string">"18310141080"</span>,<span class="string">"18310141083"</span>, <span class="string">"18310141089"</span>, <span class="string">"18310141489"</span> &#125;;</span><br><span class="line">        SortedSet&lt;<span class="keyword">String</span>&gt; sset = <span class="keyword">new</span> TreeSet&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">        <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">array</span>.length; i++) &#123;</span><br><span class="line">            sset.add(<span class="keyword">array</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">String</span>[] arrayResult2 = (<span class="keyword">String</span>[]) sset.toArray(<span class="keyword">new</span> <span class="keyword">String</span>[sset.<span class="built_in">size</span>()]);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"方法6："</span> + Arrays.toString(arrayResult2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="63：Java接口的修饰符有哪些？"><a href="#63：Java接口的修饰符有哪些？" class="headerlink" title="63：Java接口的修饰符有哪些？"></a>63：Java接口的修饰符有哪些？</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>、<span class="keyword">final</span>、<span class="keyword">abstract</span></span><br></pre></td></tr></table></figure>
<h3 id="64：Java支持的数据类型有哪些？什么是自动拆装"><a href="#64：Java支持的数据类型有哪些？什么是自动拆装" class="headerlink" title="64：Java支持的数据类型有哪些？什么是自动拆装"></a>64：Java支持的数据类型有哪些？什么是自动拆装</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span>种基本数据类型：</span><br><span class="line">    byte      <span class="number">8</span>位         取值范围  <span class="number">-2</span>^<span class="number">7</span> ~ <span class="number">2</span>^<span class="number">7</span> <span class="number">-1</span></span><br><span class="line">    short     <span class="number">16</span>位        取值范围  <span class="number">-2</span>^<span class="number">15</span> ~ <span class="number">2</span>^<span class="number">15</span> - <span class="number">1</span></span><br><span class="line">    char      <span class="number">16</span>位        取值范围  <span class="number">0</span> ~ <span class="number">2</span> ^<span class="number">16</span> - <span class="number">1</span></span><br><span class="line">    boolean   位数不明确   取值范围  true false</span><br><span class="line">    int       <span class="number">32</span>位        取值范围  <span class="number">-2</span>^<span class="number">31</span> ~ <span class="number">2</span>^<span class="number">31</span> - <span class="number">1</span></span><br><span class="line">    long      <span class="number">64</span>位        取值范围  <span class="number">-2</span>^<span class="number">63</span> ~ <span class="number">2</span>^ <span class="number">63</span> - <span class="number">1</span></span><br><span class="line">    <span class="type">float</span>     <span class="number">32</span>位        取值范围  <span class="number">1.4e-45</span> ~ <span class="number">3.40e38</span></span><br><span class="line">    double    <span class="number">64</span>位        取值范围  <span class="number">4.9e-324</span> ~ <span class="number">1.79e308</span></span><br><span class="line">注意：</span><br><span class="line">    需要注意的是，String不是基本数据类型，而是引用类型</span><br><span class="line">在jdk1<span class="number">.5</span>中引入了自动拆装箱的新特性，自动拆装箱，是指基本数据类型和引用数据类型之间的自动转换</span><br><span class="line">    基本类型转换成包装类型，称为装箱  </span><br><span class="line">    Integer intObjct = new Integer(<span class="number">2</span>); <span class="comment">//装箱 </span></span><br><span class="line">    <span class="comment">//Integer intObjct = 2 //自动装箱  </span></span><br><span class="line">    <span class="comment">//自动装箱，如果一个基本类型值出现在需要对象的环境中，会自动装箱  </span></span><br><span class="line">    如Integer 和 int 可以自动转换； Float和<span class="type">float</span>可以自动转换</span><br></pre></td></tr></table></figure>
<h3 id="65：Math-round-11-5-等于多少-Math-round-11-5-等于多少"><a href="#65：Math-round-11-5-等于多少-Math-round-11-5-等于多少" class="headerlink" title="65：Math.round(11.5)等于多少? Math.round(-11.5)等于多少?"></a>65：Math.round(11.5)等于多少? Math.round(-11.5)等于多少?</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">round方法，他表示“四舍五入”，算法为Math.floor(x+<span class="number">0.5</span>),即将原来的数字加上<span class="number">0.5</span>后再向下取整</span><br><span class="line"><span class="number">12</span>、<span class="number">-11</span></span><br></pre></td></tr></table></figure>
<h3 id="66：写一单实例类要求精简、清晰？（单例模式）"><a href="#66：写一单实例类要求精简、清晰？（单例模式）" class="headerlink" title="66：写一单实例类要求精简、清晰？（单例模式）"></a>66：写一单实例类要求精简、清晰？（单例模式）</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">饿汉式单例：</span><br><span class="line">    public class Singleton &#123;</span><br><span class="line">        private Singleton()&#123;&#125;</span><br><span class="line">        private static Singleton<span class="built_in"> instance </span>= new Singleton();</span><br><span class="line">        public static Singleton getInstance()&#123;</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">懒汉式单例：</span><br><span class="line">    public class Singleton &#123;</span><br><span class="line">        private static Singleton<span class="built_in"> instance </span>= <span class="literal">null</span>;</span><br><span class="line">        private Singleton() &#123;&#125;</span><br><span class="line">        public static synchronized Singleton getInstance()&#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) </span><br><span class="line">               <span class="built_in"> instance </span>＝ new Singleton();</span><br><span class="line">            return instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">实现一个单例有两点注意事项：</span><br><span class="line">    - 将构造器私有，不允许外界通过构造器创建对象</span><br><span class="line">    - 通过公开的静态方法向外界返回类的唯一实例</span><br></pre></td></tr></table></figure>
<h3 id="67：构造器（constructor）是否可被重写（override）-是否可被重载？是否可被继承？"><a href="#67：构造器（constructor）是否可被重写（override）-是否可被重载？是否可被继承？" class="headerlink" title="67：构造器（constructor）是否可被重写（override）?是否可被重载？是否可被继承？"></a>67：构造器（constructor）是否可被重写（override）?是否可被重载？是否可被继承？</h3><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">构造器不能被继承，因此不能重写<span class="keyword">Override</span>，但可以被重载<span class="keyword">Overload</span></span><br></pre></td></tr></table></figure>
<h3 id="68：JSP和Servlet有哪些相同点和不同点，他们之间的联系是什么？"><a href="#68：JSP和Servlet有哪些相同点和不同点，他们之间的联系是什么？" class="headerlink" title="68：JSP和Servlet有哪些相同点和不同点，他们之间的联系是什么？"></a>68：JSP和Servlet有哪些相同点和不同点，他们之间的联系是什么？</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>jsp本质就是servlet</span><br><span class="line"><span class="bullet">- </span>jsp应用于页面显示，servlet应用于逻辑控制</span><br><span class="line"><span class="bullet">- </span>setvlet中没有内置对象，jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象及HttpServlet对象得到</span><br></pre></td></tr></table></figure>
<h3 id="69：简述synchronized和java-util-concurrent-locks-Lock的异同-？"><a href="#69：简述synchronized和java-util-concurrent-locks-Lock的异同-？" class="headerlink" title="69：简述synchronized和java.util.concurrent.locks.Lock的异同 ？"></a>69：简述synchronized和java.util.concurrent.locks.Lock的异同 ？</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- Lock能完成几乎所有<span class="keyword">synchronized的功能，并有一些后者不具备的功能，如锁投票、定时锁等候、可中断锁等候等</span></span><br><span class="line"><span class="keyword">- </span><span class="keyword">synchronized </span>是<span class="keyword">Java内置的关键字，Lock </span>则是<span class="keyword">JDK </span><span class="number">5</span>中出现的一个包</span><br><span class="line">- <span class="keyword">synchronized </span>同步的代码块可以由<span class="keyword">JVM自动释放；Lock </span>需要程序员在finally块中手工释放</span><br></pre></td></tr></table></figure>
<h3 id="70：解析xml和excel分别使用什么技术？"><a href="#70：解析xml和excel分别使用什么技术？" class="headerlink" title="70：解析xml和excel分别使用什么技术？"></a>70：解析xml和excel分别使用什么技术？</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xml-<span class="keyword">do</span><span class="name">m4</span>j</span><br><span class="line">excel-poi、jxl</span><br></pre></td></tr></table></figure>
<h3 id="71：如何发布spring-boot项目，简述步骤？"><a href="#71：如何发布spring-boot项目，简述步骤？" class="headerlink" title="71：如何发布spring boot项目，简述步骤？"></a>71：如何发布spring boot项目，简述步骤？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考之前的文章《SpringBoot项目发布到自动化容器Docker步骤》点击进入</span><br></pre></td></tr></table></figure>
<h3 id="72：什么是java序列化，如何实现java序列化？"><a href="#72：什么是java序列化，如何实现java序列化？" class="headerlink" title="72：什么是java序列化，如何实现java序列化？"></a>72：什么是java序列化，如何实现java序列化？</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">概念：</span><br><span class="line">    序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化（将对象转换成二进制）。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题</span><br><span class="line">序列化：把Java对象转换为字节序列的过程。</span><br><span class="line">反序列化：把字节序列恢复为Java对象的过程。</span><br><span class="line">实现：</span><br><span class="line">    将需要被序列化的类实现Serializable接口</span><br><span class="line">注意：</span><br><span class="line">    被关键字<span class="keyword">static</span>、<span class="keyword">transient</span>修饰的变量不能被序列化。在被序列化后，<span class="keyword">transient</span>修饰的变量会被设为初始值。如<span class="keyword">int</span>型的是<span class="number">0</span>、对象型的是<span class="keyword">null</span>.</span><br></pre></td></tr></table></figure>
<h3 id="73：在JAVA中，如何跳出当前的多重嵌套循环？"><a href="#73：在JAVA中，如何跳出当前的多重嵌套循环？" class="headerlink" title="73：在JAVA中，如何跳出当前的多重嵌套循环？"></a>73：在JAVA中，如何跳出当前的多重嵌套循环？</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用<span class="keyword">break</span>; <span class="keyword">return</span> 方法。</span><br></pre></td></tr></table></figure>
<h3 id="74：面向对象的特征有哪些方面？"><a href="#74：面向对象的特征有哪些方面？" class="headerlink" title="74：面向对象的特征有哪些方面？"></a>74：面向对象的特征有哪些方面？</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>抽象：</span><br><span class="line"><span class="code">    抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。</span></span><br><span class="line"><span class="bullet">- </span>继承：</span><br><span class="line"><span class="code">    继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。</span></span><br><span class="line"><span class="bullet">- </span>封装：</span><br><span class="line"><span class="code">    封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。</span></span><br><span class="line"><span class="bullet">- </span>多态性：</span><br><span class="line"><span class="code">    多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。</span></span><br></pre></td></tr></table></figure>
<h3 id="75：Collection-和-Collections的区别？"><a href="#75：Collection-和-Collections的区别？" class="headerlink" title="75：Collection 和 Collections的区别？"></a>75：Collection 和 Collections的区别？</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collection是集合类的上级接口</span><br><span class="line">继承与他的接口主要有<span class="keyword">Set</span> 和<span class="keyword">List</span>. </span><br><span class="line">Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</span><br></pre></td></tr></table></figure>
<h3 id="76：同步和异步有何异同，在什么情况下分别使用他们？举例说明。"><a href="#76：同步和异步有何异同，在什么情况下分别使用他们？举例说明。" class="headerlink" title="76：同步和异步有何异同，在什么情况下分别使用他们？举例说明。"></a>76：同步和异步有何异同，在什么情况下分别使用他们？举例说明。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。 </span><br><span class="line">当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。</span><br></pre></td></tr></table></figure>
<h3 id="77：abstract-class和interface有什么区别"><a href="#77：abstract-class和interface有什么区别" class="headerlink" title="77：abstract class和interface有什么区别?"></a>77：abstract class和interface有什么区别?</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">声明方法的存在而不去实现它的类被叫做抽象类（<span class="keyword">abstract</span> <span class="keyword">class</span>）。</span><br><span class="line">它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。</span><br><span class="line">不能创建<span class="keyword">abstract</span> 类的实例。</span><br><span class="line">然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。</span><br><span class="line">不能有抽象构造函数或抽象静态方法。</span><br><span class="line"><span class="keyword">Abstract</span> 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。</span><br><span class="line">取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。</span><br><span class="line">接口（<span class="keyword">interface</span>）是抽象类的变体。在接口中，所有方法都是抽象的。</span><br><span class="line">多继承性可通过实现这样的接口而获得。</span><br><span class="line">接口中的所有方法都是抽象的，没有一个有程序体。</span><br><span class="line">接口只可以定义<span class="keyword">static</span> <span class="keyword">final</span>成员变量。</span><br><span class="line">接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。</span><br><span class="line">当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。</span><br><span class="line">然后，它可以在实现了该接口的类的任何对象上调用接口的方法。</span><br><span class="line">由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，<span class="keyword">instanceof</span> 运算符可以用来决定某对象的类是否实现了接口。</span><br></pre></td></tr></table></figure>
<h3 id="78：GC是什么-为什么要有GC"><a href="#78：GC是什么-为什么要有GC" class="headerlink" title="78：GC是什么? 为什么要有GC?"></a>78：GC是什么? 为什么要有GC?</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GC是垃圾收集的意思（Gabage <span class="keyword">Collection</span>）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，</span><br><span class="line">Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法</span><br></pre></td></tr></table></figure>
<h3 id="79：请说出你所知道的线程同步的方法？"><a href="#79：请说出你所知道的线程同步的方法？" class="headerlink" title="79：请说出你所知道的线程同步的方法？"></a>79：请说出你所知道的线程同步的方法？</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">wait</span><span class="params">()</span></span>:使一个线程处于等待状态，并且释放所持有的对象的lock。</span><br><span class="line"><span class="function"><span class="title">sleep</span><span class="params">()</span></span>:使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException异常。 notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。</span><br><span class="line"><span class="function"><span class="title">Allnotity</span><span class="params">()</span></span>:唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。</span><br></pre></td></tr></table></figure>
<h3 id="80：JSP的内置对象及方法？"><a href="#80：JSP的内置对象及方法？" class="headerlink" title="80：JSP的内置对象及方法？"></a>80：JSP的内置对象及方法？</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">request表示HttpServletRequest对象。它包含了有关浏览器请求的信息，并且提供了几个用于获取cookie, <span class="selector-tag">header</span>, 和session数据的有用的方法。</span><br><span class="line">response表示HttpServletResponse对象，并提供了几个用于设置送回 浏览器的响应的方法（如cookies,头信息等）</span><br><span class="line">out对象是javax<span class="selector-class">.jsp</span><span class="selector-class">.JspWriter</span>的一个实例，并提供了几个方法使你能用于向浏览器回送输出结果。</span><br><span class="line">pageContext表示一个javax<span class="selector-class">.servlet</span><span class="selector-class">.jsp</span><span class="selector-class">.PageContext</span>对象。它是用于方便存取各种范围的名字空间、servlet相关的对象的API，并且包装了通用的servlet相关功能的方法。 session表示一个请求的javax<span class="selector-class">.servlet</span><span class="selector-class">.http</span><span class="selector-class">.HttpSession</span>对象。</span><br><span class="line">Session可以存贮用户的状态信息 applicaton 表示一个javax<span class="selector-class">.servle</span><span class="selector-class">.ServletContext</span>对象。这有助于查找有关servlet引擎和servlet环境的信息 config表示一个javax<span class="selector-class">.servlet</span><span class="selector-class">.ServletConfig</span>对象。该对象用于存取servlet实例的初始化参数。</span><br><span class="line">page表示从该页面产生的一个servlet实例</span><br></pre></td></tr></table></figure>
<h3 id="81：如何现实servlet的单线程模式？"><a href="#81：如何现实servlet的单线程模式？" class="headerlink" title="81：如何现实servlet的单线程模式？"></a>81：如何现实servlet的单线程模式？</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@<span class="built_in"> page </span><span class="attribute">isThreadSafe</span>=”false”%&gt;</span><br></pre></td></tr></table></figure>
<h3 id="82：页面间对象传递的方法？"><a href="#82：页面间对象传递的方法？" class="headerlink" title="82：页面间对象传递的方法？"></a>82：页面间对象传递的方法？</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request，session，<span class="built_in">application</span>，cookie等</span><br></pre></td></tr></table></figure>
<h3 id="83：Request对象的主要方法？"><a href="#83：Request对象的主要方法？" class="headerlink" title="83：Request对象的主要方法？"></a>83：Request对象的主要方法？</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setAttribute</span><span class="params">(String name,Object)</span></span>：设置名字为name的request的参数值</span><br><span class="line"><span class="function"><span class="title">getAttribute</span><span class="params">(String name)</span></span>：返回由name指定的属性值</span><br><span class="line"><span class="function"><span class="title">getAttributeNames</span><span class="params">()</span></span>：返回request对象所有属性的名字集合，结果是一个枚举的实例</span><br><span class="line"><span class="function"><span class="title">getCookies</span><span class="params">()</span></span>：返回客户端的所有Cookie对象，结果是一个Cookie数组</span><br><span class="line"><span class="function"><span class="title">getCharacterEncoding</span><span class="params">()</span></span>：返回请求中的字符编码方式</span><br><span class="line"><span class="function"><span class="title">getContentLength</span><span class="params">()</span></span>：返回请求的Body的长度</span><br><span class="line"><span class="function"><span class="title">getHeader</span><span class="params">(String name)</span></span>：获得HTTP协议定义的文件头信息</span><br><span class="line"><span class="function"><span class="title">getHeaders</span><span class="params">(String name)</span></span>：返回指定名字的request Header的所有值，结果是一个枚举的实例</span><br><span class="line"><span class="function"><span class="title">getHeaderNames</span><span class="params">()</span></span>：返回所以request Header的名字，结果是一个枚举的实例</span><br><span class="line"><span class="function"><span class="title">getInputStream</span><span class="params">()</span></span>：返回请求的输入流，用于获得请求中的数据 getMethod()：获得客户端向服务器端传送数据的方法</span><br><span class="line"><span class="function"><span class="title">getParameter</span><span class="params">(String name)</span></span>：获得客户端传送给服务器端的有name指定的参数值</span><br><span class="line"><span class="function"><span class="title">getParameterNames</span><span class="params">()</span></span>：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例</span><br><span class="line"><span class="function"><span class="title">getParameterValues</span><span class="params">(String name)</span></span>：获得有name指定的参数的所有值</span><br><span class="line"><span class="function"><span class="title">getProtocol</span><span class="params">()</span></span>：获取客户端向服务器端传送数据所依据的协议名称</span><br><span class="line"><span class="function"><span class="title">getQueryString</span><span class="params">()</span></span>：获得查询字符串</span><br><span class="line"><span class="function"><span class="title">getRequestURI</span><span class="params">()</span></span>：获取发出请求字符串的客户端地址</span><br><span class="line"><span class="function"><span class="title">getRemoteAddr</span><span class="params">()</span></span>：获取客户端的IP地址</span><br><span class="line"><span class="function"><span class="title">getRemoteHost</span><span class="params">()</span></span>：获取客户端的名字</span><br><span class="line"><span class="function"><span class="title">getSession</span><span class="params">([Boolean create])</span></span>：返回和请求相关</span><br><span class="line">Session getServerName()：获取服务器的名字</span><br><span class="line"><span class="function"><span class="title">getServletPath</span><span class="params">()</span></span>：获取客户端所请求的脚本文件的路径</span><br><span class="line"><span class="function"><span class="title">getServerPort</span><span class="params">()</span></span>：获取服务器的端口号</span><br><span class="line"><span class="function"><span class="title">removeAttribute</span><span class="params">(String name)</span></span>：删除请求中的一个属性</span><br></pre></td></tr></table></figure>
<h3 id="84：J2ee常用的设计模式？说明工厂模式"><a href="#84：J2ee常用的设计模式？说明工厂模式" class="headerlink" title="84：J2ee常用的设计模式？说明工厂模式?"></a>84：J2ee常用的设计模式？说明工厂模式?</h3><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Java中的<span class="number">23</span>种设计模式： </span><br><span class="line">Factory（工厂模式）， Builder（建造模式）， </span><br><span class="line">Factory <span class="function"><span class="keyword">Method</span>（工厂方法模式）， <span class="title">Prototype</span>（原始模型模式），<span class="title">Singleton</span>（单例模式）， <span class="title">Facade</span>（门面模式），</span></span><br><span class="line"><span class="function"><span class="title">Adapter</span>（适配器模式）， <span class="title">Bridge</span>（桥梁模式）， </span></span><br><span class="line"><span class="function"><span class="title">Composite</span>（合成模式）， <span class="title">Decorator</span>（装饰模式）， </span></span><br><span class="line"><span class="function"><span class="title">Flyweight</span>（享元模式）， <span class="title">Proxy</span>（代理模式）， </span></span><br><span class="line"><span class="function"><span class="title">Command</span>（命令模式）， <span class="title">Interpreter</span>（解释器模式）， </span></span><br><span class="line"><span class="function"><span class="title">Visitor</span>（访问者模式）， <span class="title">Iterator</span>（迭代子模式）， </span></span><br><span class="line"><span class="function"><span class="title">Mediator</span>（调停者模式）， <span class="title">Memento</span>（备忘录模式），</span></span><br><span class="line"><span class="function"><span class="title">Observer</span>（观察者模式）， <span class="title">State</span>（状态模式）， </span></span><br><span class="line"><span class="function"><span class="title">Strategy</span>（策略模式）， <span class="title">Template</span> <span class="title">Method</span>（模板方法模式）， </span></span><br><span class="line"><span class="function"><span class="title">Chain</span> <span class="title">Of</span> <span class="title">Responsibleity</span>（责任链模式）</span></span><br><span class="line"><span class="function">工厂模式：工厂模式是一种经常被使用到的模式，</span></span><br><span class="line"><span class="function">根据工厂模式实现的类可以根据提供的数据生成一组类中某一个类的实例，</span></span><br><span class="line"><span class="function">通常这一组类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作。</span></span><br><span class="line"><span class="function">首先需要定义一个基类，该类的子类通过不同的方法实现了基类中的方法。</span></span><br><span class="line"><span class="function">然后需要定义一个工厂类，工厂类可以根据条件生成不同的子类实例。</span></span><br><span class="line"><span class="function">当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。</span></span><br></pre></td></tr></table></figure>
<h3 id="85：List、Map、Set三个接口，存取元素时，各有什么特点？"><a href="#85：List、Map、Set三个接口，存取元素时，各有什么特点？" class="headerlink" title="85：List、Map、Set三个接口，存取元素时，各有什么特点？"></a>85：List、Map、Set三个接口，存取元素时，各有什么特点？</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List 以特定次序来持有元素，可有重复元素。</span><br><span class="line"><span class="keyword">Set</span> 无法拥有重复元素,内部排序。</span><br><span class="line"><span class="keyword">Map</span> 保存<span class="keyword">key</span>-<span class="keyword">value</span>值，<span class="keyword">value</span>可多值。</span><br></pre></td></tr></table></figure>
<h3 id="86：如何对数据库做优化？"><a href="#86：如何对数据库做优化？" class="headerlink" title="86：如何对数据库做优化？"></a>86：如何对数据库做优化？</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>：数据库设计</span><br><span class="line">    数据库表：字段类型、字段长度、注释、字段命名规范</span><br><span class="line">    数据库索引：外键、关联字段、查询频率比较高的字段、</span><br><span class="line">            如果数据表字段&gt;<span class="number">20</span>，则最多支持<span class="number">16</span>个索引</span><br><span class="line">            如果数据表字段&lt;<span class="number">20</span>，则根据查询频率字段来定</span><br><span class="line">    数据库视图：相当于一张临时表，业务中，尽量少使用</span><br><span class="line">    数据库引擎：根据业务，选择对应的表引擎技术</span><br><span class="line">    数据库存储过程：尽量少用</span><br><span class="line">    数据库字符：UTF<span class="number">-8</span>、或者和页面字符保持一致</span><br><span class="line">    数据库监听器/触发器：一般用于调度任务或者备份还原</span><br><span class="line"><span class="number">2</span>：业务调用的sql语句优化</span><br><span class="line">    xml：</span><br><span class="line">    尽量少关联表，效率最高关联<span class="number">4</span>张表，如果多于<span class="number">4</span>张表，则需要开启两个链接事务，但是这两个事务，必须在一个service当中。</span><br><span class="line">    如果是查询语句，则不建议使用*</span><br><span class="line">    如果是查询语句，where条件后面，最好使用索引字段进行关联</span><br><span class="line"><span class="number">3</span>：数据库服务器的搭建（集群）</span><br><span class="line">    主从配置：</span><br><span class="line">    读写分离：</span><br><span class="line">    自动化（容器）：</span><br></pre></td></tr></table></figure>
<h3 id="87：如何对JVM进行性能调优？"><a href="#87：如何对JVM进行性能调优？" class="headerlink" title="87：如何对JVM进行性能调优？"></a>87：如何对JVM进行性能调优？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考图片</span><br></pre></td></tr></table></figure>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/FVVBZN3l1eSsMN20PSunguxeeeQpGOibO2gY7ia7QWwQR3N08xjz4MjP9ERddp6t12ZibENAE5iaicsOyleic1evkibaw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h3 id="88：如何实现集群模式下，session共享？"><a href="#88：如何实现集群模式下，session共享？" class="headerlink" title="88：如何实现集群模式下，session共享？"></a>88：如何实现集群模式下，session共享？</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">一：Tomcat本身配置</span><br><span class="line">1：登录成功之后，将session信息存放到redis中，利用拦截器来过滤查找session（推荐）</span><br><span class="line">2：配置tomcat文件server.xml</span><br><span class="line">    &lt;Engine <span class="attribute">name</span>=<span class="string">"Catalina"</span> <span class="attribute">defaultHost</span>=<span class="string">"localhost"</span> <span class="attribute">jvmRoute</span>=<span class="string">"8081"</span>&gt;</span><br><span class="line"> &lt;Cluster <span class="attribute">className</span>=<span class="string">"org.apache.catalina.ha.tcp.SimpleTcpCluster"</span>/&gt;</span><br><span class="line"> 如果还没有session信息同步，则需要在项目的启动容器web.xml中，在display-name标签下面，添加&lt;distributable/&gt;</span><br><span class="line">二：使用redis服务器</span><br></pre></td></tr></table></figure>
<h3 id="89：程序员如果想换行，应该怎么处理？"><a href="#89：程序员如果想换行，应该怎么处理？" class="headerlink" title="89：程序员如果想换行，应该怎么处理？"></a>89：程序员如果想换行，应该怎么处理？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">回车</span><br></pre></td></tr></table></figure>
<h3 id="90：公司如果想换一个灯泡-请问需要几个java工程师？"><a href="#90：公司如果想换一个灯泡-请问需要几个java工程师？" class="headerlink" title="90：公司如果想换一个灯泡,请问需要几个java工程师？"></a>90：公司如果想换一个灯泡,请问需要几个java工程师？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调用构造方法，或者调用换灯泡的方法即可</span><br></pre></td></tr></table></figure>
<h3 id="91：Hibernate一级缓存和二级缓存的区别？"><a href="#91：Hibernate一级缓存和二级缓存的区别？" class="headerlink" title="91：Hibernate一级缓存和二级缓存的区别？"></a>91：Hibernate一级缓存和二级缓存的区别？</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>一级缓存是session独享，默认开启，无需配置</span><br><span class="line"><span class="number">2.</span>二级缓存是session共享，需要在配置文件中开启，可以指定缓存区域块</span><br></pre></td></tr></table></figure>
<h3 id="92：Hibernate有几种查询方式？"><a href="#92：Hibernate有几种查询方式？" class="headerlink" title="92：Hibernate有几种查询方式？"></a>92：Hibernate有几种查询方式？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HQL查询、Criteria查询、NativeSQL查询</span><br></pre></td></tr></table></figure>
<h3 id="93：你对加班怎么看？能接受出差吗？"><a href="#93：你对加班怎么看？能接受出差吗？" class="headerlink" title="93：你对加班怎么看？能接受出差吗？"></a>93：你对加班怎么看？能接受出差吗？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以接受加班，但是希望是有效率的加班，出差根据自身回答</span><br></pre></td></tr></table></figure>
<h3 id="94：谈谈个人3-5年的职业规划？"><a href="#94：谈谈个人3-5年的职业规划？" class="headerlink" title="94：谈谈个人3-5年的职业规划？"></a>94：谈谈个人3-5年的职业规划？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从技术和管理两方面回答</span><br></pre></td></tr></table></figure>
<h3 id="95：在项目开发中，曾经遇到什么困难、难解的问题？"><a href="#95：在项目开发中，曾经遇到什么困难、难解的问题？" class="headerlink" title="95：在项目开发中，曾经遇到什么困难、难解的问题？"></a>95：在项目开发中，曾经遇到什么困难、难解的问题？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">至今没有，就是这么自信，这是为什么呢？</span><br></pre></td></tr></table></figure>
<h3 id="96：为什么从上家公司离职？"><a href="#96：为什么从上家公司离职？" class="headerlink" title="96：为什么从上家公司离职？"></a>96：为什么从上家公司离职？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自身回答</span><br></pre></td></tr></table></figure>
<h3 id="97：你喜欢在什么样的团队进行工作？"><a href="#97：你喜欢在什么样的团队进行工作？" class="headerlink" title="97：你喜欢在什么样的团队进行工作？"></a>97：你喜欢在什么样的团队进行工作？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自身回答</span><br></pre></td></tr></table></figure>
<h3 id="98：做一个简单的自我介绍？"><a href="#98：做一个简单的自我介绍？" class="headerlink" title="98：做一个简单的自我介绍？"></a>98：做一个简单的自我介绍？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自身回答</span><br></pre></td></tr></table></figure>
<h3 id="99：工作中，如果你和项目组长或者领导的意见不一样，应该怎么处理？"><a href="#99：工作中，如果你和项目组长或者领导的意见不一样，应该怎么处理？" class="headerlink" title="99：工作中，如果你和项目组长或者领导的意见不一样，应该怎么处理？"></a>99：工作中，如果你和项目组长或者领导的意见不一样，应该怎么处理？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自身回答</span><br></pre></td></tr></table></figure>
<h3 id="100：遇到需求变更如何处理？"><a href="#100：遇到需求变更如何处理？" class="headerlink" title="100：遇到需求变更如何处理？"></a>100：遇到需求变更如何处理？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际情况回答</span><br></pre></td></tr></table></figure>
<hr>
<p><em>转自码神联盟。</em></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/12/15/2018-12-15-数据库_30道面试题/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">&lt;</strong>
      <div class="article-nav-title">
        
          数据库_30道面试题
        
      </div>
    </a>
  
  
    <a href="/2018/12/15/2018-12-15-常用网站/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">常用网站</div>
      <strong class="article-nav-caption">&gt;</strong>
    </a>
  
</nav>

  
</article>


<div class="ds-share share" data-thread-key="2018-12-15-Java_100道面试题" data-title="Java_100道面试题" data-url="http://javar.xyz/2018/12/15/2018-12-15-Java_100道面试题/" data-images="http://pjv20i5zh.bkt.clouddn.com/javar_xyz_head.jpg" data-content="Java_100道面试题">
    <div class="ds-share-inline">
      <ul class="ds-share-icons-16">
      	<li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
        <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
        <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
        <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
        <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>
      </ul>
      <div class="ds-share-icons-more">
      </div>
    </div>
 </div>
 





</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2018 刘文旭
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>